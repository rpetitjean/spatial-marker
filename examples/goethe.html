<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Goethe's Theory of Colors</title>
    <meta name="description" content="A demo of the Spatial-Marker component">
    
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://rpetitjean.github.io/spatial-marker/spatial-marker.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AdaRoseCannon/aframe-xr-boilerplate/simple-navmesh-constraint.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.5.x/dist/aframe-environment-component.min.js"></script>
    <script src="gradient-color.js"></script>
    <script src="intro-overlay.js" ></script>

    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="github.css">

<!-- Fades in glb models when the user is in a defined color zone -->
<script>
AFRAME.registerComponent('area-fade-gradient', {
  schema: {
    target:     { type: 'selector' },         // GLB with gradient-color
    zone:       { type: 'string' },           // 'orange', 'blue', etc
    maxOpacity: { type: 'number', default: 1 },   // when this zone is active
    minOpacity: { type: 'number', default: 0.1 }, // otherwise
    speed:      { type: 'number', default: 2 }    // fade speed (per second)
  },

  init: function () {
    const data   = this.data;
    this.active  = false;
    this.currentOpacity = data.minOpacity;
    this.targetOpacity  = data.minOpacity;

    const sceneEl = this.el.sceneEl;
    this.onZoneChanged = (e) => {
      const activeName = e.detail && e.detail.name;
      this.active = (activeName === data.zone);
    };

    if (sceneEl) {
      sceneEl.addEventListener('goethe-zone-changed', this.onZoneChanged);
    }
  },

  remove: function () {
    const sceneEl = this.el.sceneEl;
    if (sceneEl && this.onZoneChanged) {
      sceneEl.removeEventListener('goethe-zone-changed', this.onZoneChanged);
    }
  },

  tick: function (time, dt) {
    const targetEl = this.data.target;
    if (!targetEl) return;

    // Set target opacity based on zone activity
    this.targetOpacity = this.active ? this.data.maxOpacity : this.data.minOpacity;

    // Smooth fade
    const dtSec      = dt / 1000;
    const lerpFactor = 1.0 - Math.exp(-this.data.speed * dtSec);
    this.currentOpacity = THREE.MathUtils.lerp(
      this.currentOpacity,
      this.targetOpacity,
      lerpFactor
    );

    // Apply opacity to target's gradient-color shader
    const mesh = targetEl.getObject3D('mesh');
    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material || !node.material.uniforms) return;
      if (node.material.uniforms.opacity) {
        node.material.uniforms.opacity.value = this.currentOpacity;
      }
    });

    // Toggle visibility for perf
    targetEl.setAttribute('visible', this.currentOpacity > 0.01);
  }

  
});

</script>

<!-- Fade on Event: fades-in and out the three info texts when clicking a defined object-->
<script>
AFRAME.registerComponent('fade-on-event', {
  schema: {
    targets:      { type: 'string' },           // CSS selector: "#goethe-text, .caption"
    event:        { type: 'string', default: 'click' },
    duration:     { type: 'number', default: 2 },   // fade in/out duration (seconds)
    from:         { type: 'number', default: 0 },   // hidden opacity
    to:           { type: 'number', default: 1 },   // visible opacity
    delay:        { type: 'number', default: 0 },   // delay before fade-in (seconds)
    hold:         { type: 'number', default: 0 },   // time fully visible before fade-out (0 = no auto fade-out)
    once:         { type: 'boolean', default: false }, // if true: only first full cycle
    autoInit:     { type: 'boolean', default: true },  // hide targets at init
    group:        { type: 'string',  default: '' }     // group name for mutual exclusion
  },

  init: function () {
    this.targets = [];

    // state machine: 'idle' | 'delay' | 'fadeIn' | 'hold' | 'fadeOut'
    this.state = 'idle';
    this.timer = 0;
    this._alreadyTriggered = false;
    this.lastOpacity = this.data.from;
    this.fadeStartOpacity = this.data.from;

    this._updateTargetList();

    if (this.data.autoInit) {
      this._hideTargetsImmediately();
    }

    if (this.data.event === 'click') {
      this.el.classList.add('clickable');
    }

    this._onEvent = this._onEvent.bind(this);
    this._onGlobalFadeStart = this._onGlobalFadeStart.bind(this);

    this.el.addEventListener(this.data.event, this._onEvent);

    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl) {
      sceneEl.addEventListener('fade-on-event-started', this._onGlobalFadeStart);
    }
  },

  remove: function () {
    this.el.removeEventListener(this.data.event, this._onEvent);
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl) {
      sceneEl.removeEventListener('fade-on-event-started', this._onGlobalFadeStart);
    }
  },

  update: function (oldData) {
    if (!oldData || oldData.targets !== this.data.targets) {
      this._updateTargetList();
      if (this.data.autoInit) {
        this._hideTargetsImmediately();
      }
    }
  },

  _updateTargetList: function () {
    const sel = this.data.targets;
    if (!sel) {
      this.targets = [];
      return;
    }
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (!sceneEl) {
      this.targets = [];
      return;
    }
    this.targets = Array.from(sceneEl.querySelectorAll(sel));
  },

  _hideTargetsImmediately: function () {
    this.targets.forEach((el) => {
      el.setAttribute('visible', false);
      el.addEventListener('model-loaded', () => {
        this._setOpacityOnMesh(el, this.data.from);
      });
    });
  },

  _onEvent: function () {
    // Ignore if an animation is already running
    if (this.state !== 'idle') return;

    // If single-use and already did one full cycle, ignore
    if (this.data.once && this._alreadyTriggered) return;

    // Announce to the group that THIS one is starting
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl && this.data.group) {
      sceneEl.emit('fade-on-event-started', {
        group: this.data.group,
        source: this.el
      });
    }

    this._alreadyTriggered = true;
    this.timer = 0;

    if (this.data.delay > 0) {
      this.state = 'delay';
    } else {
      this.state = 'fadeIn';
      this.fadeStartOpacity = this.data.from;
    }

    this._setOpacityAll(this.data.from);
  },

  // When another member of the same group starts, fade THIS one out
  _onGlobalFadeStart: function (e) {
    const detail = e.detail || {};
    const group = detail.group;
    const source = detail.source;

    if (!group || group !== this.data.group) return;
    if (source === this.el) return; // that's us, ignore

    // If currently idle and already at "from", nothing to do
    if (this.state === 'idle' && this.lastOpacity <= this.data.from + 0.001) {
      return;
    }

    // Start a smooth fade-out from current opacity ‚Üí from
    this.state = 'fadeOut';
    this.timer = 0;
    this.fadeStartOpacity = this.lastOpacity;
  },

  _setOpacityAll: function (value) {
    this.lastOpacity = value;
    this.targets.forEach((el) => this._setOpacityOnMesh(el, value));
  },

  _setOpacityOnMesh: function (el, value) {
    const v = THREE.MathUtils.clamp(value, 0, 1);
    const mesh = el.getObject3D('mesh');

    el.setAttribute('visible', v > 0.01);

    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material) return;
      const mats = Array.isArray(node.material) ? node.material : [node.material];

      mats.forEach((mat) => {
        if (!mat) return;

        mat.transparent = true;
        mat.opacity = v;
        mat.needsUpdate = true;

        if (mat.uniforms && mat.uniforms.opacity) {
          mat.uniforms.opacity.value = v;
        }
      });
    });
  },

  tick: function (time, dt) {
    if (this.state === 'idle' || this.targets.length === 0) return;

    const dtSec = dt / 1000;
    const data  = this.data;
    const dur   = Math.max(data.duration, 0.0001);

    this.timer += dtSec;

    switch (this.state) {
      case 'delay': {
        if (this.timer >= data.delay) {
          this.state = 'fadeIn';
          this.fadeStartOpacity = data.from;
          this.timer = 0;
        }
        break;
      }

      case 'fadeIn': {
        const p = Math.min(this.timer / dur, 1);
        const v = THREE.MathUtils.lerp(this.fadeStartOpacity, data.to, p);
        this._setOpacityAll(v);

        if (p >= 1) {
          this.timer = 0;
          if (data.hold > 0) {
            this.state = 'hold';
          } else {
            this.state = 'idle';
          }
        }
        break;
      }

      case 'hold': {
        if (this.timer >= data.hold) {
          this.state = 'fadeOut';
          this.fadeStartOpacity = this.lastOpacity; // should be ~data.to
          this.timer = 0;
        }
        break;
      }

      case 'fadeOut': {
        const p = Math.min(this.timer / dur, 1);
        const v = THREE.MathUtils.lerp(this.fadeStartOpacity, data.from, p);
        this._setOpacityAll(v);

        if (p >= 1) {
          this.state = 'idle';
        }
        break;
      }
    }
  }
});

</script>

<!-- Export Scene Module: export scene with lines in VR Mode-->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.173.0/build/three.module.js';
  import { GLTFExporter } from 'https://unpkg.com/three@0.173.0/examples/jsm/exporters/GLTFExporter.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.173.0/examples/jsm/controls/OrbitControls.js';

  // ---------- helpers ----------
  const tsName = (prefix='spatial-marker')=>{
    const t=new Date(), pad=n=>(n<10?'0':'')+n;
    return `${prefix}_${t.getFullYear()}${pad(t.getMonth()+1)}${pad(t.getDate())}_${pad(t.getHours())}${pad(t.getMinutes())}${pad(t.getSeconds())}.glb`;
  };
  const syncWorld = (root)=>{ try{ root.updateMatrixWorld(true); }catch(_){} };

  // ---------- Blender-safe guards (hide risky nodes + sanitize geometry) ----------
  function makeBlenderSafeGuards(root){
    const hidden = [];
    // Hide A-Frame UI / texture-driven nodes (controllers, hint planes, any [src], etc.)
    const selectors = [
      '#left-hand', '#right-hand', '.drawingArea',
      '[src]', '[material*="src:"]'
    ];
    selectors.forEach(sel=>{
      document.querySelectorAll(sel).forEach(el=>{
        const o = el?.object3D;
        if (o && o.visible) { hidden.push([o, o.visible]); o.visible = false; }
      });
    });

    // Hide meshes with texture maps; sanitize geometry numbers; ensure indices/normals.
    root.traverse(o=>{
      if (!o.isMesh) return;
      // Hide textured meshes so we don't embed CORS-tainted images.
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      if (mats.some(m => m && (m.map || m.emissiveMap || m.roughnessMap || m.metalnessMap || m.normalMap))) {
        hidden.push([o, o.visible]); o.visible = false; return;
      }

      const g = o.geometry;
      if (!g || !g.isBufferGeometry) return;

      // Drop invalid or empty
      const pos = g.getAttribute('position');
      if (!pos || pos.count < 3) { hidden.push([o, o.visible]); o.visible = false; return; }

      // Clamp drawRange and clean NaN/Inf in attributes
      g.setDrawRange(0, pos.count);
      ['position','normal','uv','color'].forEach(name=>{
        const a = g.getAttribute(name);
        if (!a) return;
        let dirty = false;
        const arr = a.array;
        for (let i=0;i<arr.length;i++){
          const v = arr[i];
          if (!Number.isFinite(v)) { arr[i] = 0; dirty = true; }
        }
        if (dirty) a.needsUpdate = true;
      });
      if (!g.getAttribute('normal') || !g.getAttribute('normal').count) {
        try { g.computeVertexNormals(); } catch(_){}
      }
      // Ensure indexed geometry (Blender is happier with indices).
      if (!g.index) {
        try { g.setIndex([...Array(pos.count).keys()]); } catch(_){}
      }
    });

    // restore fn
    return ()=>hidden.forEach(([o, v])=>{ o.visible = v; });
  }

  // ---------- floating window viewer (unchanged, with robust close) ----------
  function openFloatingWindowWithBlob(blob, filename){
    const url = URL.createObjectURL(blob);

    if (!document.getElementById('glb-fwin-css')) {
      const style = document.createElement('style');
      style.id = 'glb-fwin-css';
      style.textContent = `
        .glb-fwin{position:fixed;top:6vh;left:6vw;width:70vw;height:70vh;background:#0b0d10;border:1px solid #334155;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);display:flex;flex-direction:column;z-index:99999;overflow:hidden; font-family: system-ui, Segoe UI, Arial;}
        .glb-fwin-header{display:flex;gap:8px;align-items:center;background:#111827;color:#e5e7eb;padding:8px 10px;user-select:none}
        .glb-fwin-title{font:600 14px/1 system-ui, Segoe UI, Arial; color:#e5e7eb}
        .glb-fwin-spacer{flex:1}
        .glb-fwin-btn{padding:6px 10px;border-radius:8px;background:#1f2937;border:1px solid #334155;color:#e5e7eb;text-decoration:none;cursor:pointer}
        .glb-fwin-btn:hover{background:#0f172a}
        .glb-fwin-body{position:relative;flex:1;min-height:0}
        .glb-fwin-body canvas{display:block;width:100%;height:100%}
        .glb-fwin-resize{position:absolute;right:0;bottom:0;width:18px;height:18px;cursor:nwse-resize;background:linear-gradient(135deg,transparent 50%,#334155 50%)}
      `;
      document.head.appendChild(style);
    }

    const frame = document.createElement('div'); frame.className = 'glb-fwin';
    const header = document.createElement('div'); header.className = 'glb-fwin-header';
    const title = document.createElement('div'); title.className = 'glb-fwin-title'; title.textContent = filename;
    const spacer = document.createElement('div'); spacer.className = 'glb-fwin-spacer';
    const btnDL  = document.createElement('a');  btnDL.className='glb-fwin-btn'; btnDL.textContent='‚¨áÔ∏è Download'; btnDL.href=url; btnDL.download=filename;
    const btnExt = document.createElement('a');  btnExt.className='glb-fwin-btn'; btnExt.textContent='‚ÜóÔ∏é About this viewer'; btnExt.href='https://github.com/donmccurdy/three-gltf-viewer'; btnExt.target='_blank'; btnExt.rel='noopener';
    const btnClose = document.createElement('button'); btnClose.className='glb-fwin-btn'; btnClose.textContent='‚úï'; btnClose.type='button';
    btnClose.style.minWidth = '44px'; btnClose.style.minHeight = '34px';
    header.append(title, spacer, btnDL, btnExt, btnClose);

    const body = document.createElement('div'); body.className = 'glb-fwin-body';
    const resizeHandle = document.createElement('div'); resizeHandle.className = 'glb-fwin-resize';
    body.appendChild(resizeHandle);
    frame.append(header, body);
    document.body.appendChild(frame);

    // Drag (ignore clicks on buttons)
 let dragging=false, dragSX=0, dragSY=0, ox=0, oy=0, pid=null;

    header.addEventListener('pointerdown', e=>{
      if (e.button!==0) return;
      if (e.target.closest('.glb-fwin-btn')) return;
 dragging=true; pid=e.pointerId; dragSX=e.clientX; dragSY=e.clientY;
  const r=frame.getBoundingClientRect(); ox=r.left; oy=r.top;
  header.setPointerCapture(pid);
    });
    header.addEventListener('pointermove', e=>{
  if (!dragging || e.pointerId!==pid) return;
  const nx=Math.max(0,Math.min(window.innerWidth-frame.offsetWidth,  ox+(e.clientX-dragSX)));
  const ny=Math.max(0,Math.min(window.innerHeight-frame.offsetHeight, oy+(e.clientY-dragSY)));
  frame.style.left=nx+'px'; frame.style.top=ny+'px';
    });
    header.addEventListener('pointerup', e=>{
      if (e.pointerId!==pid) return;
      dragging=false; try{ header.releasePointerCapture(pid);}catch(_){}
      pid=null;
    });
    [btnDL,btnExt,btnClose].forEach(el=>el.addEventListener('pointerdown', e=>e.stopPropagation(), {passive:true}));

    // Resize
    let resizing=false, rsId=null, resSX=0, resSY=0, sw=0, sh=0;

   resizeHandle.addEventListener('pointerdown', e=>{ rsId=e.pointerId; resizing=true; resSX=e.clientX; resSY=e.clientY; sw=frame.offsetWidth; sh=frame.offsetHeight; resizeHandle.setPointerCapture(rsId); });
resizeHandle.addEventListener('pointermove', e=>{
  if (!resizing || e.pointerId!==rsId) return;
  const nw=Math.max(360, sw+(e.clientX-resSX));
  const nh=Math.max(240, sh+(e.clientY-resSY));
  frame.style.width=nw+'px'; frame.style.height=nh+'px';
  onResize();
});

    resizeHandle.addEventListener('pointerup', e=>{ if (e.pointerId!==rsId) return; resizing=false; try{ resizeHandle.releasePointerCapture(rsId);}catch(_){ } rsId=null; });

    // Three viewer
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    body.appendChild(renderer.domElement);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0d10);
    const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 1000); camera.position.set(1.8,1.2,2.2);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
    scene.add(new THREE.HemisphereLight(0xffffff, 0x202020, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,7); scene.add(dir);
    const grid = new THREE.GridHelper(10,10,0x335577,0x223344); grid.material.opacity=0.35; grid.material.transparent=true; scene.add(grid);

    (async ()=>{
      const { GLTFLoader } = await import('https://unpkg.com/three@0.173.0/examples/jsm/loaders/GLTFLoader.js');
      new GLTFLoader().load(url, (gltf)=>{
        const root = gltf.scene || gltf.scenes?.[0];
        scene.add(root);
        const box = new THREE.Box3().setFromObject(root);
        const size = box.getSize(new THREE.Vector3()).length() || 1;
        const center = box.getCenter(new THREE.Vector3());
        controls.target.copy(center);
        camera.position.copy(center).add(new THREE.Vector3(0.5, size*0.4, size*0.8));
        camera.near=size/1000; camera.far=size*10; camera.updateProjectionMatrix();
      });
    })();

    function onResize(){
      const w = body.clientWidth, h = body.clientHeight;
      camera.aspect = Math.max(1e-6, w / Math.max(1, h));
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }
    const ro = new ResizeObserver(onResize); ro.observe(body); onResize();
    renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene, camera); });

    // Close
    function doClose(){
      try { renderer.setAnimationLoop(null); } catch(_){}
      try { ro.disconnect(); } catch(_){}
      try { URL.revokeObjectURL(url); } catch(_){}
      frame.remove();
      document.removeEventListener('keydown', onEsc, true);
    }
    const onEsc = (e)=>{ if (e.key==='Escape'){ e.stopPropagation(); e.preventDefault(); doClose(); } };
    document.addEventListener('keydown', onEsc, true);
    btnClose.addEventListener('click', e=>{ e.preventDefault(); e.stopPropagation(); doClose(); });
    btnClose.addEventListener('keydown', e=>{ if (e.key==='Enter'||e.key===' '){ e.preventDefault(); doClose(); } });
  }

  // ---------- export (normal vs blender-safe) ----------
  const REGULAR_OPTS = { binary:true, onlyVisible:true, embedImages:true };
  const BLENDER_OPTS = { binary:true, onlyVisible:true, embedImages:true, includeCustomExtensions:false, forceIndices:true, truncateDrawRange:true };

  async function exportToFloatingWindow(rootObj3D, {blenderSafe=false}={}){
    // Leave VR so window is visible on headset
    const sceneEl = document.querySelector('a-scene');
    if (sceneEl?.is('vr-mode')) { try { await sceneEl.exitVR(); } catch(_){} }

    syncWorld(rootObj3D);
    const exporter = new GLTFExporter();
    const filename = tsName(blenderSafe ? 'spatial-marker_blender' : 'spatial-marker');

    let restore = ()=>{};
    if (blenderSafe) restore = makeBlenderSafeGuards(rootObj3D);

    exporter.parse(
      rootObj3D,
      (ab)=>{
        restore();
        const blob = new Blob([ab], { type: 'model/gltf-binary' });
        openFloatingWindowWithBlob(blob, filename);
      },
      (err)=>{ restore(); console.warn('[export] failed:', err); },
      blenderSafe ? BLENDER_OPTS : REGULAR_OPTS
    );
  }

  // ---------- triggers ----------
  // Desktop:
  window.addEventListener('keydown', (e)=>{
    if (e.repeat) return;
    const k = (e.key||'').toLowerCase();
    if (k === 'e' || k === 'b') {
      e.preventDefault();
      const scene = document.querySelector('a-scene')?.object3D;
      if (!scene) return;
      exportToFloatingWindow(scene, { blenderSafe: k === 'b' });
    }
  });

  // VR dual-grip ‚Üí Blender-safe
  const HOLD_MS = 600;
  const left  = document.getElementById('left-hand');
  const right = document.getElementById('right-hand');
  const state = { left:false, right:false, timer:null, cooldown:false };

  function tryStartTimer(){
    if (state.timer || state.cooldown) return;
    if (state.left && state.right){
      state.timer = setTimeout(()=>{
        state.timer = null;
        if (state.left && state.right){
          state.cooldown = true; setTimeout(()=> state.cooldown=false, 1200);
          const scene = document.querySelector('a-scene')?.object3D;
          if (scene) exportToFloatingWindow(scene, { blenderSafe:true });
        }
      }, HOLD_MS);
    }
  }
  function onPress(e){ const s=(e.currentTarget===left)?'left':'right'; state[s]=true; tryStartTimer(); }
  function onRelease(e){ const s=(e.currentTarget===left)?'left':'right'; state[s]=false; if(state.timer){ clearTimeout(state.timer); state.timer=null; } }

  ['gripdown','squeezestart'].forEach(ev=>{ left?.addEventListener(ev,onPress); right?.addEventListener(ev,onPress); });
  ['gripup','squeezeend'  ].forEach(ev=>{ left?.addEventListener(ev,onRelease); right?.addEventListener(ev,onRelease); });
</script>

<!-- Shimmer Material : effect use to animate the 6 color diagram -->
<script>
AFRAME.registerComponent('shimmer-material', {
  schema: {
    opacity:          { type: 'number', default: 1.0 },
    shimmerIntensity: { type: 'number', default: 1.0 }, // how strong the shimmer is
    shimmerSpeed:     { type: 'number', default: 1.0 }  // how fast it moves
  },

  init: function () {
    this.shaderMaterials = [];
    this.applyMaterial = this.applyMaterial.bind(this);

    this.el.addEventListener('loaded', this.applyMaterial);
    this.el.addEventListener('model-loaded', this.applyMaterial);
    this.el.addEventListener('materialtextureloaded', this.applyMaterial);

    this.applyMaterial();
  },

  makeShaderMaterial: function (baseMap) {
    const data = this.data;
    baseMap.wrapS = baseMap.wrapT = THREE.ClampToEdgeWrapping;

    return new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        time:            { value: 0 },
        opacity:         { value: data.opacity },
        shimmerIntensity:{ value: data.shimmerIntensity },
        shimmerSpeed:    { value: data.shimmerSpeed },
        baseMap:         { value: baseMap }
      },

      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,

      fragmentShader: `
        uniform float time;
        uniform float opacity;
        uniform float shimmerIntensity;
        uniform float shimmerSpeed;
        uniform sampler2D baseMap;
        varying vec2 vUv;

        // very simple 2D noise
        float random(vec2 st) {
          return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453);
        }
        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));

          vec2 u = f * f * (3.0 - 2.0 * f);

          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        void main() {
          vec4 baseSample = texture2D(baseMap, vUv);
          if (baseSample.a < 0.01) {
            discard;
          }

          // animated noise over the whole plane
          vec2 st = vUv * 4.0;
          st += vec2(time * shimmerSpeed * 0.2, -time * shimmerSpeed * 0.17);

          float n = noise(st);        // 0..1
          n = clamp(n, 0.0, 1.0);

          // brightness deviation around 1.0 (e.g. 0.5..1.5)
          float amp = 0.5 * shimmerIntensity;
          float brightness = 1.0 + (n - 0.5) * 2.0 * amp;

          // build a white ‚Äúboost‚Äù so highlights go to white, not grey
          vec3 whiteBoost = mix(vec3(0.0), vec3(1.0), max(0.0, brightness - 1.0));

          // add white highlight on top of original color
          vec3 finalRGB = baseSample.rgb + whiteBoost * 0.85;
          finalRGB = clamp(finalRGB, 0.0, 1.0);

          // slight alpha variation
          float alphaFactor = 1.0 + (n - 0.5) * 0.4 * shimmerIntensity;
          float finalA = baseSample.a * opacity * alphaFactor;
          finalA = clamp(finalA, 0.0, 1.0);

          gl_FragColor = vec4(finalRGB, finalA);
        }
      `
    });
  },

  applyMaterial: function () {
    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;

    const list = this.shaderMaterials;

    mesh.traverse((node) => {
      if (!node.isMesh) return;
      const oldMat = node.material;

      if (Array.isArray(oldMat)) {
        const newMats = [];
        for (let i = 0; i < oldMat.length; i++) {
          const m = oldMat[i];
          if (!m || !m.map) { newMats.push(m); continue; }
          const sm = this.makeShaderMaterial(m.map);
          newMats.push(sm);
          list.push(sm);
        }
        node.material = newMats;
      } else {
        if (!oldMat || !oldMat.map) return;
        const sm = this.makeShaderMaterial(oldMat.map);
        node.material = sm;
        list.push(sm);
      }
    });
  },

  tick: function (timeMs) {
    const t = timeMs / 1000.0;
    for (let i = 0; i < this.shaderMaterials.length; i++) {
      const m = this.shaderMaterials[i];
      if (m.uniforms.time) m.uniforms.time.value = t;
    }
  }
});
</script>

<!-- Goethe Zones script, react to rig's position in the 6 different color zones to set up the colour palette -->
<script>
AFRAME.registerComponent('goethe-zones', {
  schema: {
    rig: { type: 'selector', default: '#rig' }
  },

  init: function () {
    this.rig = this.data.rig || document.querySelector('#rig');
    this.currentZone = null;
    this._rigPos = new THREE.Vector3();

    /* =========================
       PALETTES (24 colors each)
       ========================= */
    this.palettes = {
      blue: [
        '#081427','#3572ee','#0b1a33','#3a7aff',
        '#0f2244','#4584ff','#132a55','#4f8eff',
        '#163266','#5998ff','#193a77','#63a2ff',
        '#1d4288','#6dacff','#214a99','#77b6ff',
        '#2552aa','#81c0ff','#295abb','#8bcaFF',
        '#2d62cc','#95d4ff','#316add','#9fdeff'
      ],
      green: [
        '#06210f','#36ca63','#0a2f16','#3ad86a',
        '#0e3d1d','#3fe672','#124c24','#49ec7a',
        '#165a2b','#54f283','#1a6832','#5ff88b',
        '#1e7639','#6aff94','#228440','#75ff9d',
        '#269247','#80ffa6','#2aa04e','#8bffaf',
        '#2eae55','#96ffb8','#32bc5c','#a1ffc1'
      ],
      indigo: [
        '#130827','#6737b7','#1a0b33','#6e3bc3',
        '#210f3f','#7540cf','#28134b','#7c44db',
        '#2f1757','#8348e7','#361b63','#8a4cf3',
        '#3d1f6f','#9150ff','#44237b','#9b5aff',
        '#4b2787','#a564ff','#522b93','#af6eff',
        '#592f9f','#b978ff','#6033ab','#c382ff'
      ],
      orange: [
        '#2b1304','#ea7217','#3a1a05','#fa7a19',
        '#4a2206','#ff8423','#5a2a07','#ff8f35',
        '#6a3208','#ff9a47','#7a3a09','#ffa559',
        '#8a420b','#ffb06b','#9a4a0d','#ffbb7d',
        '#aa520f','#ffc68f','#ba5a11','#ffd1a1',
        '#ca6213','#ffdcb3','#da6a15','#ffe7c5'
      ],
      red: [
        '#2b0404','#ea1717','#3a0505','#fa1919',
        '#4a0606','#ff2323','#5a0707','#ff3535',
        '#6a0808','#ff4747','#7a0909','#ff5959',
        '#8a0b0b','#ff6b6b','#9a0d0d','#ff7d7d',
        '#aa0f0f','#ff8f8f','#ba1111','#ffa1a1',
        '#ca1313','#ffb3b3','#da1515','#ffc5c5'
      ],
      yellow: [
        '#3f3300','#f9cc00','#514000','#ffd11a',
        '#635000','#ffd633','#756000','#ffdb4d',
        '#877000','#ffe066','#998000','#ffe580',
        '#ab9000','#ffea99','#b89a00','#ffefb3',
        '#c5a400','#fff4cc','#d2ae00','#fff9e6',
        '#dfb800','#fffaf0','#ecc200','#fffdf7'
      ]
    };

    /* =========================
       ZONES (navmeshes)
       ========================= */
    this.zones = [
      { name: 'blue',   el: document.querySelector('[gltf-model="#navmesh-blue"]'),   box: null },
      { name: 'green',  el: document.querySelector('[gltf-model="#navmesh-green"]'),  box: null },
      { name: 'indigo', el: document.querySelector('[gltf-model="#navmesh-indigo"]'), box: null },
      { name: 'orange', el: document.querySelector('[gltf-model="#navmesh-orange"]'), box: null },
      { name: 'red',    el: document.querySelector('[gltf-model="#navmesh-red"]'),    box: null },
      { name: 'yellow', el: document.querySelector('[gltf-model="#navmesh-yellow"]'), box: null }
    ];
  },

  tick: function () {
    const rig = this.rig;
    if (!rig || !rig.object3D) return;

    rig.object3D.getWorldPosition(this._rigPos);

    let activeZone = null;

    for (const z of this.zones) {
      if (!z.el) continue;

      const mesh = z.el.getObject3D('mesh') || z.el.object3D;
      if (!mesh) continue;

      if (!z.box) {
        z.box = new THREE.Box3().setFromObject(mesh);
      }

      if (z.box.containsPoint(this._rigPos)) {
        activeZone = z;
        break;
      }
    }

    if (activeZone === this.currentZone) return;

    /* =========================
       ZONE CHANGED
       ========================= */
    const zoneName = activeZone ? activeZone.name : null;
    this.el.emit('goethe-zone-changed', { name: zoneName });

    if (activeZone && this.palettes[activeZone.name]) {
      const palette = this.palettes[activeZone.name].slice();

      /* üî• IMPORTANT FIXES üî• */

      // 1. Update spatial-marker with REAL array
      rig.setAttribute('spatial-marker', {
        colors: palette
      });

      // 2. Notify listeners (drawingZones, UI, etc.)
      rig.emit('spatial-marker-colors-changed', {
        colors: palette,
        zone: activeZone.name
      });

      console.log('[goethe-zones] active zone:', activeZone.name);
    }

    this.currentZone = activeZone;
  }
});
</script>

<!-- Flat-override component : sets opacity for written texts -->
<script>
AFRAME.registerComponent('flat-override', {
  schema: {
    color:   { type: 'color',  default: '#ffffff' },
    opacity: { type: 'number', default: 1 }
  },

  init() {
    this.el.addEventListener('model-loaded', () => {
      const mesh = this.el.getObject3D('mesh');
      if (!mesh) return;

      mesh.traverse((node) => {
        if (!node.isMesh) return;

        node.material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(this.data.color),
          transparent: this.data.opacity < 1,
          opacity: this.data.opacity,
          roughness: 0.8,
          metalness: 0
        });

        node.material.needsUpdate = true;
      });
    });
  },

  update() {
    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material) return;

      node.material.color.set(this.data.color);
      node.material.opacity = this.data.opacity;
      node.material.transparent = this.data.opacity < 1;
    });
  }
});
</script>

<!-- Background Music Manager -->
<script>
AFRAME.registerComponent('bgm-manager', {
  schema: {
    src: { type: 'string' },
    volume: { type: 'number', default: 0.5 }
  },

  init() {
    this.audio = null;

    this.started = false;   // user clicked Enter at least once
    this.enabled = true;    // user toggle intent

    // Start only when the INTRO Enter button is clicked
    this._onEnterClickCapture = (e) => {
      if (this.started) return;

      const btn = e.target.closest?.('.intro-overlay-buttons button');
      if (!btn) return;

      this.started = true;
      if (this.enabled) this._ensureAudioAndPlay();
    };
    document.addEventListener('click', this._onEnterClickCapture, true);

    // Public API for your UI button
    window.__bgm = {
      toggle: () => this.toggle(),
      play: () => this.play(),
      pause: () => this.pause(),
      isOn: () => this.enabled,          // UI intent
      isPlaying: () => this.isPlaying()
    };
  },

  remove() {
    document.removeEventListener('click', this._onEnterClickCapture, true);
  },

  _ensureAudio() {
    if (this.audio) return;

    this.audio = new Audio(this.data.src);
    this.audio.loop = true;
    this.audio.preload = 'auto';
    this.audio.volume = 0; // start silent until play succeeds
  },

  isPlaying() {
    return !!(this.audio && !this.audio.paused);
  },

  async _ensureAudioAndPlay() {
    this._ensureAudio();

    try {
      await this.audio.play();
    } catch (err) {
      console.warn('[bgm] play blocked/failed:', err);
      return;
    }

    this.audio.volume = this.data.volume;
    this.el.sceneEl.emit('bgm-toggled', { enabled: true });
  },

  play() {
    if (!this.started) return;
    if (!this.enabled) return;

    if (!this.audio || this.audio.paused) {
      this._ensureAudioAndPlay();
      return;
    }

    this.audio.volume = this.data.volume;
    this.el.sceneEl.emit('bgm-toggled', { enabled: true });
  },

  pause() {
    if (!this.audio || this.audio.paused) return;

    this.audio.volume = 0;
    this.audio.pause();

    this.el.sceneEl.emit('bgm-toggled', { enabled: false });
  },

  toggle() {
    // Allow toggling intent even before Enter
    this.enabled = !this.enabled;

    if (!this.started) {
      this.el.sceneEl.emit('bgm-toggled', { enabled: this.enabled });
      return;
    }

    if (this.enabled) this.play();
    else this.pause();

    this.el.sceneEl.emit('bgm-toggled', { enabled: this.enabled });
  }
});
</script>

<!-- Laser-Beam script -->
<script>
AFRAME.registerComponent('laser-beam', {
  schema: {
    length: { type: 'number', default: 0.6 },
    radius: { type: 'number', default: 0.0025 },

    mode: { type: 'string', default: 'occluded' }, // 'occluded' | 'xray'

    idleColor:  { type: 'color', default: '#ffffff' },
    hoverColor: { type: 'color', default: '#00ff66' },
    fadeSpeed:  { type: 'number', default: 22 }
  },

  init() {
    // Build cylinder once (axis = +Y by default)
    this.el.setAttribute('geometry', {
      primitive: 'cylinder',
      height: 1,
      radius: 1,
      openEnded: true,
      segmentsRadial: 18
    });

    // Reused objects for alignment
    this._up = new THREE.Vector3(0, 1, 0);
    this._dir = new THREE.Vector3();
    this._origin = new THREE.Vector3();
    this._q = new THREE.Quaternion();

    // Color fade state
    this._idle = new THREE.Color(this.data.idleColor);
    this._hover = new THREE.Color(this.data.hoverColor);
    this._current = this._idle.clone();
    this._target = this._idle.clone();

    this._isHovering = false;

    // Intersections come from the HAND's raycaster (parent)
    const hand = this.el.parentEl;
    this._onHit = (e) => {
      const els = (e.detail && e.detail.els) || [];
      this._isHovering = !!els[0];
      this._target.copy(this._isHovering ? this._hover : this._idle);
    };
    this._onClear = () => {
      this._isHovering = false;
      this._target.copy(this._idle);
    };

    hand.addEventListener('raycaster-intersection', this._onHit);
    hand.addEventListener('raycaster-intersection-cleared', this._onClear);

    this._materialTweaked = false;
  },

  remove() {
    const hand = this.el.parentEl;
    if (hand) {
      hand.removeEventListener('raycaster-intersection', this._onHit);
      hand.removeEventListener('raycaster-intersection-cleared', this._onClear);
    }
  },

  _tweakMaterialOnce() {
    if (this._materialTweaked) return;

    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;

    // Draw beams late, without touching global renderer sorting.
    mesh.renderOrder = (this.data.mode === 'xray') ? 10001 : 10000;

    const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
    mats.forEach((m) => {
      if (!m) return;

      // Both beams: don't mess the depth buffer
      m.depthWrite = false;
      m.transparent = true;

      if (this.data.mode === 'xray') {
        // Always visible (won‚Äôt disappear on transparent/glass)
        m.depthTest = false;
      } else {
        // Occluded by solid geometry
        m.depthTest = true;
      }

      m.needsUpdate = true;
    });

    this._materialTweaked = true;
  },

  tick(time, dt) {
    const hand = this.el.parentEl;
    const rc = hand && hand.components && hand.components.raycaster;
    if (!rc) return;

    this._tweakMaterialOnce();

    // ----- align cylinder to raycaster origin+direction -----
    const d = rc.data;
    this._dir.set(d.direction.x, d.direction.y, d.direction.z);
    if (this._dir.lengthSq() < 1e-8) return;
    this._dir.normalize();

    this._origin.set(d.origin.x, d.origin.y, d.origin.z);

    const len = this.data.length;
    this.el.object3D.position.copy(this._origin).addScaledVector(this._dir, len * 0.5);
    this._q.setFromUnitVectors(this._up, this._dir);
    this.el.object3D.quaternion.copy(this._q);
    this.el.object3D.scale.set(this.data.radius, len, this.data.radius);

    // ----- fast color fade -----
    const dtSec = dt / 1000;
    const k = 1 - Math.exp(-this.data.fadeSpeed * dtSec);
    this._current.lerp(this._target, k);
    this.el.setAttribute('material', 'color', `#${this._current.getHexString()}`);
  }
});
</script>


  </head>

  <body>

  <div id="ui-topright">
  <button id="btn-music" class="ui-circle" aria-label="Toggle music" title="Music">
    <span id="icon-music"></span>
  </button>
</div>

<a class="github-fab"
   href="https://github.com/rpetitjean/spatial-marker/blob/main/examples/goethe.html"
   target="_blank"
   rel="noopener noreferrer"
   aria-label="Open source code on GitHub">
  <span class="gh-dot" aria-hidden="true"></span>
  <span class="gh-label">Source</span>
</a>

<!-- Info Pop-up  -->
<script>
(() => {
  /* =========================
     1) LANGUAGE (intro-overlay storage + browser fallback + toggle)
     ========================= */

  const LANGS = { EN: 'en', FR: 'fr' };
  const INTRO_STORAGE_KEY = 'intro-lang'; // MUST match intro-overlay storageKey

  function browserPrefLang() {
    const prefs = (navigator.languages && navigator.languages.length)
      ? navigator.languages
      : [navigator.language || 'en'];
    const first = String(prefs[0] || '').toLowerCase();
    return first.startsWith('fr') ? LANGS.FR : LANGS.EN;
  }

  function storedIntroLang() {
    try {
      const stored = localStorage.getItem(INTRO_STORAGE_KEY);
      if (!stored) return null;
      const lc = String(stored).toLowerCase();
      return lc.startsWith('fr') ? LANGS.FR : LANGS.EN;
    } catch (_) {
      return null;
    }
  }

  function syncLangFromIntroStorageOrBrowser() {
    currentLang = storedIntroLang() || browserPrefLang();
  }

  // initial guess (will be re-synced later anyway)
  let currentLang = storedIntroLang() || browserPrefLang();

  /* =========================
     2) CONTENT (EN / FR)
     ========================= */

  const CONTENT = {
    en: {
      infoBtn: 'Info',
      toggleLabel: 'FR / EN',
      menuTitleHTML: `
        This
        <a href="https://immersiveweb.dev/" target="_blank" rel="noopener noreferrer">WebXR</a>
        experience was created with
        <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a>
        to highlight some fun that can be made with the
        <a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">Spatial-Marker component</a>,
        and it also opens ideas by Goethe on colors with music by Franz Liszt.
      `,
      back: '‚Üê',
      pages: {
        vr:     { title: 'Video', text: ``, hideImage: true },
        about:  { title: 'About this experience', text: `This <a href="https://immersiveweb.dev/" target="_blank" rel="noopener noreferrer">WebXR</a> experience was thought to highlight some possibilities of the Spatial-Marker component for A-Frame. This component make it simple to set up a color palette and drawing areas in any A-frame experience. <br> <br>
        While working on this <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a> component I got interested in how drawing in a 3D space was shaping deeper my comprehension and relationship with colors. Later I found about the studies of Newton and Goethe on colors and I got particularly intrigued by this diagram. I liked the idea of setting up a deeply researched scientific work on colors by Goethe to end up presenting this highly symbolic diagram, with not much explanations neither demonstration... and this is probably the fact that the poet minds often gets over the scientific mind! 
        <br> <br>
        By getting this diagram at the center of the room and by showing its meanings presented both in their german original and their english translations, I wished users to get a time to reflect on the possible meanings and nature of colors Goethe defined and to invite users to spend time with each of these 6 key colors.<br> 
        <br> 
        red = "sch√∂n" / beautiful ; orange = "edel" / noble ; yellow = "gut" / good ; green = "n√ºtzlich" / useful ; blue = "gemein" / common ; violet = "unn√∂thig" / unnecessary <br>
        red-orange "Vernunft" / Reason ; yellow-green "Verstand" / Understanding ; green-blue = "Sinnlichkeit" / Sensuality ; violet-red = "Phantasie / Fantasy"`, image: 'assets/goethe-colors/info/about.jpg' },
        goethe: {
          title: 'Johann Wolfgang von Goethe (1749-1832)',
          text: `Writer, poet, playwright, and scientist, Goethe appears today as one of the brightest minds of the 18th and 19th centuries. <br> <br>
          A name that echoes in Germany with a deep resonance as in European Literary history. Goethe is the "father" romantic hero Werther, a young man exalted by nature, antic poetry and love. <br> <br>
          Goethe is also the author of play "Faust": the story of a man making a deal with the devil to reach a deeper and richer sense of life no humans ever reached. "Faust" opens deep reflections on the meaning of life and the research of an absolute. This is likely this absolute and his passion for paintings that would lead Goethe to study colors and to write his "Color Theory". Hundreds of pages of scientific exploration on the nature of colors, pigments, lights and their possible meanings... <br><br>
          The text is available in Public Domain
          <a href="https://www.gutenberg.org/cache/epub/50572/pg50572.txt" target="_blank" rel="noopener noreferrer">here</a>
          by the
          <a href="https://www.gutenberg.org/" target="_blank" rel="noopener noreferrer">Gutenberg Project</a>.`,
          image: 'assets/goethe-colors/info/goethe.jpg'
        },
        liszt:  { title: 'Franz Liszt', text: `One of the most acclaimed pianists of his time. The name of Franz Liszt evokes a virtuoso who reached an "absolute" as a composer and a performer. Franz Liszt played all over Europe, being acclaimed in every city. The German writer Heinrich Heine would write about "Lisztomania".<br> <br>
        This piece, "Berceuse in D-Flat Major" was first composed in 1854 and reworked to this final version in 1862. It sounds like a stream of visions and melodies made of silence and high notes, low and fast rhythm. It invites us to let our minds flow in different movements. <br> <br>
        I hope it will accompany you well in exploring the possible meanings of colors. <br>
        <br>
        This piece from Liszt was made using a CC0 Piano by <a href="https://versilian-studios.com/vcsl-keys/" target="_blank" rel="noopener noreferrer">Versilian Studios</a>, and the music is free to use under the CC0 Licence.<br>
        <br>
        -> It is an amazing piece of music and I invite you to look through the different versions by great performers you will find on music platforms.`, image: 'assets/goethe-colors/info/liszt.jpg' },
        marker: { title: 'Spatial-Marker', text: `The Spatial-Marker was created as an easy to set up drawing tool for <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a> experiences.<br>
        <br>
        By setting one or multiple drawing areas and 24 hex color values, <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a> creators can fastly and easily allow drawing in 3D in their WebXR experiences. This component comes with its own movement controls for VR, using the thumbsticks to move, the trigger to draw and the grip to swap hands.<br>
       <br>  The component is published <a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">here</a> under MIT License and you are free to use it. 
        <br> Also you can find further examples of what you can make with it <a href="https://rpetitjean.github.io/spatial-marker/" target="_blank" rel="noopener noreferrer">here</a>.`, image: 'assets/goethe-colors/info/spatial-marker.jpg' },
        free:   { title: 'MIT + CC0', text: `<a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">The Spatial-Marker component</a> code is published under MIT License and you are free to use it and for it. <br>
        <br>All assets here have been created by me, <a href="https://www.remipetitjean.com/" target="_blank" rel="noopener noreferrer">R√©mi Petitjean</a>, or published under the Public Domain and are 100% free to use and re-use without credit mandatory. I release all the 3D assets and texture under CC0. <br>
        The music from Liszt was created using a CC0 Piano by <a href="<a href="https://versilian-studios.com/vcsl-keys/" target="_blank" rel="noopener noreferrer">Versilian Studios</a>, and the music is free to use under the CC0 Licence.  `, image: 'assets/goethe-colors/info/license.jpg' }
      },
      menuButtons: {
        vr: 'Watch Preview Video',
        goethe: 'Johann Wolfgang von Goethe',
        liszt: 'Franz Liszt',
        marker: 'Spatial-Marker for A-Frame',
        free: 'MIT + CC0'
      }
    },

    fr: {
      infoBtn: 'Info',
      toggleLabel: 'FR / EN',
      menuTitleHTML: `
        Cette exp√©rience
        <a href="https://immersiveweb.dev/" target="_blank" rel="noopener noreferrer">WebXR</a>
        a √©t√© cr√©√©e avec
        <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a>
        pour montrer ce qu‚Äôon peut faire avec le composant
        <a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">Spatial-Marker</a>,
        et pour ouvrir des pistes de r√©flexion de Goethe sur les couleurs, avec la musique de Franz Liszt.
      `,
      back: '‚Üê',
      pages: {
        vr:     { title: 'Vid√©o', text: `Ajoute ici tes liens vers des vid√©os VR.`, hideImage: true },
        about: { title: 'Quelques informations', text: `Cette exp√©rience de <a href="https://immersiveweb.dev/" target="_blank" rel="noopener noreferrer">WebXR</a> a √©t√© cr√©√©e afin d'explorer quelques possibilit√©s offertes par le <a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">Spatial-Marker</a>, component pour le framework <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a>. Ce component a pour but de proposer une solution simple pour dessiner en 3D via un projet cr√©√© avec A-Frame. <br>
        <br> En travaillant √† la publication de ce component, j'ai r√©alis√© que l'action de dessiner en 3D et en r√©alit√© virtuelle m'ouvrait √† une appr√©hension plus profonde des couleurs. J'ai ensuite d√©couvert les recherches de Newton et puis de Goethe sur les couleurs et j'ai trouv√© ce diagramme intriguant, issu de la "Th√©orie des couleurs" de Goethe. Ce qui est particuli√®rement frappant c'est la distance qu'a ce diagramme avec toutes les observations scientifiques √©mises par Goethe sur les couleurs. Ce diagramme est symbolique, non scientifique, il ne repose sur rien d'autre que l'intuition et il est l√† au milieu de cette pi√®ce pour ouvrir cette question: quelle est la signification des couleurs? <br>
        <br> rouge = "sch√∂n" / "beautiful ; orange = "edel" / noble ; jaune = "gut" / good ; vert = "n√ºtzlich" / useful ; bleu = "gemein" / common ; violet = "unn√∂thig" / unnecessary <br>
        rouge-orange "Vernunft" / Reason ; jaune-vert "Verstand" / Understanding ; vert-bleu = "Sinnlichkeit" / Sensuality ; violet-rouge = "Phantasie / Fantasy`, image: 'assets/goethe-colors/info/about.jpg' },
        goethe: { title: 'Goethe', text: `Po√®te, auteur de th√©√¢tre et scientifique, Goethe sonne aujourd'hui comme le nom d'un des plus brillants esprits de son temps.<br>
<br> Un nom qui r√©sonne en Allemagne comme dans toute l'histoire litt√©raire europ√©enne. Goethe est le cr√©ateur du h√©ros romantique Werther, un jeune exalt√© par la nature, par la po√©sie antique et par un amour (impossible).
<br> Goethe est aussi l'auteur de "Faust" : une pi√®ce qui nous montre un homme qui a fait un pacte avec le diable en √©change de la connaissance de la plus grande richesse et profondeur de la vie, telle qu'aucun.e humain.e ne l'a ressentie. "Faust" ouvre des r√©flexions profondes sur le sens de la vie et la recherche d'un "absolu". C'est peut-√™tre cet "absolu" et sa passion pour la peinture qui l'am√®neront √† vouloir comprendre les couleurs et √† r√©aliser sa vaste "Th√©orie des couleurs". Plusieurs centaines de pages d'exploration scientifique, sur la nature des couleurs, sur les pigments, sur la lumi√®re ainsi que la potentielle signification des couleurs... <br> <br> 
Le texte est disponible dans le domaine public
<a href="https://www.gutenberg.org/cache/epub/50572/pg50572.txt" target="_blank" rel="noopener noreferrer">ici</a>
par le
<a href="https://www.gutenberg.org/" target="_blank" rel="noopener noreferrer">Projet Gutenberg</a>.`, image: 'assets/goethe-colors/info/goethe.jpg' },
        liszt:  { title: 'Franz Liszt', text: `L'un des pianistes les plus acclam√©s de son temps.<br>
<br>
Le nom de Franz Liszt √©voque un virtuose qui a atteint la perfection, √† la fois comme interpr√®te et comme compositeur. Franz Liszt a jou√© √† travers l'Europe enti√®re, triomphant dans chaque ville. L'√©crivain allemand Heinrich Heine a qualifi√© l'effet de Liszt sur la sc√®ne musicale de ¬´ Lisztomania ¬ª.
<br><br>
Ce morceau, ¬´ Berceuse en r√© b√©mol majeur ¬ª, fut d'abord compos√© en 1854, puis retravaill√© dans une version finale en 1862. Il r√©sonne comme un flot de visions et de m√©lodies faites de silences et de notes hautes, basses et rapides. Il nous invite √† laisser notre esprit flotter √† travers diff√©rents mouvements.
<br><br>
J'esp√®re qu'il vous accompagnera comme il se doit dans l'exploration des possibles significations des couleurs.
<br><br>
Ce morceau de Liszt a √©t√© r√©alis√© en utilisant une biblioth√®que de piano en CC0 par <a href="https://versilian-studios.com/vcsl-keys/" target="_blank" rel="noopener noreferrer">Versilian Studios</a>, et la musique est libre d'utilisation sous licence CC0.
<br><br>
‚Üí C'est un morceau de musique tr√®s riche et √©tonnant, et je vous invite √† d√©couvrir les diff√©rentes versions interpr√©t√©es par une multitude d'artistes, disponibles sur les plateformes de musique.
         `, image: 'assets/goethe-colors/info/liszt.jpg' },
        marker: { title: 'Spatial-Marker', text: `Le <a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">Spatial-Marker</a> component a √©t√© cr√©√© comme une solution simple pour dessiner en 3D via un projet cr√©√© avec <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a>.<br><br>
En d√©finissant une ou plusieurs drawing areas ainsi que 24 valeurs de couleurs hex, les cr√©ateurs qui utilisent <a href="https://aframe.io/" target="_blank" rel="noopener noreferrer">A-Frame</a> peuvent rapidement et simplement permettre de dessiner en 3D √† l‚Äôint√©rieur de l‚Äôespace 3D de leurs exp√©riences <a href="https://immersiveweb.dev/" target="_blank" rel="noopener noreferrer">WebXR</a>.
Ce component est d√©velopp√© avec son propre mod√®le de locomotion, qui utilise le joystick pour le movement, le trigger pour dessiner et le grip pour le changement de main.

<br><br>
Le component est publi√© ici sous la licence MIT et est de fait libre d‚Äôutilisation.
<br>
Vous pourrez aussi trouver davantage d‚Äôexemples de l‚Äôusage de ce component sur cette page.
       `, image: 'assets/goethe-colors/info/spatial-marker.jpg' },
        free:   { title: 'MIT + CC0', text: `Le code du 
<a href="https://github.com/rpetitjean/spatial-marker" target="_blank" rel="noopener noreferrer">
Spatial-Marker component
</a>
est publi√© sous licence MIT et vous √™tes libre de l‚Äôutiliser et de le modifier.
<br><br>

Tous les assets pr√©sent√©s ici ont √©t√© cr√©√©s par moi, <a href="https://www.remipetitjean.com/" target="_blank" rel="noopener noreferrer">R√©mi Petitjean</a>, ou sont publi√©s sous le Public Domain, et sont 100 % libres d‚Äôutilisation et de r√©utilisation, sans credit mandatory.  
Tous les assets 3D et les textures sont publi√©s sous licence CC0.
<br><br>

La musique de Liszt a √©t√© cr√©√©e en utilisant une CC0 Piano par 
<a href="https://versilian-studios.com/vcsl-keys/" target="_blank" rel="noopener noreferrer">
Versilian Studios</a>, et la musique est free to use sous licence CC0.

`, image: 'assets/goethe-colors/info/license.jpg' }
      },
      menuButtons: {
        vr: 'Voir la vid√©o de pr√©sentation',
      about:  'Quelques informations',
        goethe: 'Johann Wolfgang von Goethe',
        liszt: 'Franz Liszt',
        marker: 'Spatial-Marker pour A-Frame',
        free: 'MIT + CC0'
      }
    }
  };

  const MENU_IMAGE = 'assets/goethe-colors/Spatial-marker.gif';

  /* =========================
     3) DOM
     ========================= */

  const btn = document.createElement('button');
  btn.className = 'intro-lang-switch';
  btn.textContent = 'Info';
  btn.style.left = '12px';
  btn.style.right = 'auto';
  btn.style.display = 'none';
  btn.style.zIndex = '99998';
  document.body.appendChild(btn);

  const overlay = document.createElement('div');
  overlay.id = 'info-overlay';
  overlay.innerHTML = `
    <div id="info-modal" role="dialog" aria-modal="true" aria-label="Information">
      <img id="info-gif" src="${MENU_IMAGE}" alt="Info">
      <div id="info-content">
        <div id="info-menu">
          <button id="info-lang-toggle" type="button" class="info-link" style="min-height:40px;">FR / EN</button>
          <div class="info-menu-title" id="info-menu-title"></div>

          <button class="info-link" data-page="vr"></button>
          <button class="info-link" data-page="about"></button>
          <button class="info-link" data-page="goethe"></button>
          <button class="info-link" data-page="liszt"></button>
          <button class="info-link" data-page="marker"></button>
          <button class="info-link" data-page="free"></button>
        </div>

        <div id="info-detail" style="display:none;">
          <button id="info-back" type="button">‚Üê</button>
          <div id="info-title"></div>
          <div id="info-text"></div>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const modal       = overlay.querySelector('#info-modal');
  const imgEl       = overlay.querySelector('#info-gif');
  const menu        = overlay.querySelector('#info-menu');
  const detail      = overlay.querySelector('#info-detail');
  const back        = overlay.querySelector('#info-back');
  const titleEl     = overlay.querySelector('#info-title');
  const textEl      = overlay.querySelector('#info-text');
  const menuTitleEl = overlay.querySelector('#info-menu-title');
  const toggleBtn   = overlay.querySelector('#info-lang-toggle');
  const menuButtons = Array.from(menu.querySelectorAll('.info-link[data-page]'));

  let enabled = false;
  let currentPage = null; // null = menu
  let onKeyDown = null;

  /* =========================
     4) IMAGE HANDLING
     ========================= */

  function setHeaderImage({ src, hide } = {}) {
    if (!imgEl) return;
    if (hide) {
      imgEl.style.display = 'none';
      imgEl.removeAttribute('src');
      return;
    }
    imgEl.style.display = 'block';
    if (src) imgEl.src = src;
  }

  /* =========================
     5) RENDER
     ========================= */

  function getLangPack() {
    return CONTENT[currentLang] || CONTENT.en;
  }

  function renderMenuTexts() {
    const L = getLangPack();
    btn.textContent = L.infoBtn || 'Info';
    toggleBtn.textContent = L.toggleLabel || 'FR / EN';
    menuTitleEl.innerHTML = L.menuTitleHTML || '';

    menuButtons.forEach(b => {
      const key = b.dataset.page;
      b.textContent = (L.menuButtons && L.menuButtons[key]) ? L.menuButtons[key] : key;
    });

    back.textContent = L.back || '‚Üê';
  }

  function showMenu() {
    currentPage = null;
    menu.style.display = 'block';
    detail.style.display = 'none';
    setHeaderImage({ src: MENU_IMAGE, hide: false });
    renderMenuTexts();
  }

  function showPage(key) {
    const L = getLangPack();
    const p = (L.pages && L.pages[key]) ? L.pages[key] : null;
    if (!p) return;

    currentPage = key;
    titleEl.textContent = p.title || '';
    textEl.innerHTML = p.text || '';
    setHeaderImage({ src: p.image, hide: !!p.hideImage });

    menu.style.display = 'none';
    detail.style.display = 'block';
  }

  /* =========================
     6) OPEN/CLOSE (‚úÖ sync language right before opening)
     ========================= */

  function openModal() {
    if (!enabled) return;

    // ‚úÖ bulletproof: always use same language as intro overlay (stored)
    syncLangFromIntroStorageOrBrowser();

    overlay.style.display = 'block';
    showMenu();

    onKeyDown = (e) => {
      if (e.key === 'Escape') closeModal();
    };
    document.addEventListener('keydown', onKeyDown, true);
  }

  function closeModal() {
    overlay.style.display = 'none';
    if (onKeyDown) {
      document.removeEventListener('keydown', onKeyDown, true);
      onKeyDown = null;
    }
  }

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal();
  });

  overlay.addEventListener('mousedown', (e) => {
    if (e.target === overlay) closeModal();
  });

  modal.addEventListener('mousedown', (e) => e.stopPropagation());

  menu.addEventListener('click', (e) => {
    const b = e.target.closest('.info-link[data-page]');
    if (!b) return;
    showPage(b.dataset.page);
  });

  back.addEventListener('click', showMenu);

  /* =========================
     7) TOGGLE LANGUAGE
     ========================= */

  toggleBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    currentLang = (currentLang === LANGS.FR) ? LANGS.EN : LANGS.FR;

    // keep in sync with intro-overlay ‚Äúremembered language‚Äù
    try { localStorage.setItem(INTRO_STORAGE_KEY, currentLang); } catch (_) {}

    if (overlay.style.display === 'block') {
      if (currentPage) showPage(currentPage);
      else showMenu();
    } else {
      renderMenuTexts();
    }
  });

  /* =========================
     8) ENABLE AFTER INTRO (use intro event + also listen to language changes)
     ========================= */

  const scene = document.querySelector('a-scene');
  if (scene) {
    scene.addEventListener('intro-start', (e) => {
      enabled = true;
      btn.style.display = 'block';

      // If intro provides a lang, use it; otherwise use stored/browser
      const introLang = String(e.detail?.lang || '').toLowerCase();
      if (introLang) currentLang = introLang.startsWith('fr') ? LANGS.FR : LANGS.EN;
      else syncLangFromIntroStorageOrBrowser();

      renderMenuTexts();
    }, { once: true });

    // Bonus: if user switches LANG on intro overlay later (you emit this)
    scene.addEventListener('intro-language-changed', (e) => {
      const l = String(e.detail?.lang || '').toLowerCase();
      if (!l) return;
      currentLang = l.startsWith('fr') ? LANGS.FR : LANGS.EN;
      renderMenuTexts();
    });
  } else {
    window.addEventListener('DOMContentLoaded', () => {
      const s = document.querySelector('a-scene');
      if (!s) return;

      s.addEventListener('intro-start', (e) => {
        enabled = true;
        btn.style.display = 'block';

        const introLang = String(e.detail?.lang || '').toLowerCase();
        if (introLang) currentLang = introLang.startsWith('fr') ? LANGS.FR : LANGS.EN;
        else syncLangFromIntroStorageOrBrowser();

        renderMenuTexts();
      }, { once: true });

      s.addEventListener('intro-language-changed', (e) => {
        const l = String(e.detail?.lang || '').toLowerCase();
        if (!l) return;
        currentLang = l.startsWith('fr') ? LANGS.FR : LANGS.EN;
        renderMenuTexts();
      });
    });
  }

  /* =========================
     9) OPTIONAL: Debug (uncomment if needed)
     ========================= */
  // console.log('[info] navigator.language(s)=', navigator.languages, navigator.language);
  // console.log('[info] localStorage intro-lang=', (() => { try { return localStorage.getItem(INTRO_STORAGE_KEY); } catch(e){ return 'blocked'; } })());
})();
</script>

<img id="info-gif" src="assets/goethe-colors/info.gif" ...>

<!-- JS for Music UI  -->
<script>
const ICON_PLAY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M11.596 8.697 6.214 11.96A.5.5 0 0 1 5.5 11.53V4.47a.5.5 0 0 1 .714-.43l5.382 3.263a.5.5 0 0 1 0 .894z"/></svg>`;
const ICON_PAUSE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 3.5A.5.5 0 0 1 6 4v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm5 0A.5.5 0 0 1 11 4v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>`;

function refreshMusicIcon(){
  const on = window.__bgm?.isOn?.() ?? false;
  document.getElementById('icon-music').innerHTML = on ? ICON_PAUSE : ICON_PLAY;
}
document.getElementById('btn-music').addEventListener('click', ()=>{
  window.__bgm?.toggle?.();
  refreshMusicIcon();
});
function bindBgmIconToScene(){
  const scene = document.querySelector('a-scene');
  if (!scene) return false;
  scene.addEventListener('bgm-toggled', refreshMusicIcon);
  refreshMusicIcon();
  return true;
}

window.addEventListener('DOMContentLoaded', () => {
  // Try now, and if scene isn't there yet, retry a few times.
  if (bindBgmIconToScene()) return;
  let tries = 0;
  const t = setInterval(() => {
    tries++;
    if (bindBgmIconToScene() || tries > 50) clearInterval(t);
  }, 50);
});

</script>

    <a-scene 
    light="defaultLightsEnabled: false" 
    background="color: #ffffff" 
    renderer="colorManagement: linear; physicallyCorrectLights: true; sortTransparentObjects: true; "
    goethe-zones
    bgm-manager="src: assets/goethe-colors/FranzLiszt_Berceuse_D_FlatMajor_174_ScoreToMIDI_CC0_compressed.mp3;
               volume: 0.75;
               fadeInMs: 900;
               fadeOutMs: 600;
               pauseWhenHidden: true"
    intro-overlayy="
    backgroundColor: #ffffff;
    textColor: #000000;
    fontFamily: system-ui;
    fontSize: 1.1rem;
    lang1Code: en;
    lang2Code: fr;
    buttonLabel1: Enter;
    buttonLabel2: Entrer;
    loadingText1: Loading assets‚Ä¶;
    loadingText2: Chargement des √©l√©ments‚Ä¶;
    charSpeed: 55;         
    lineGap: 300;         
    imageFadeDuration: 2000;

    text1: a poet, scientist and philosopher came to a long work on colors,<br>
    he studied light, pigments, paintings, psychology...<br>
    <br>
    And he made his 'Color Theory', as a wide set of reflections and ideas.<br>There he drafted a purely 'intuitive' diagram<br> 
    <br> 
    ‚ûî on a possible meaning of colors<br>;

    text2:un po√®te, scientifique et philosophe a longuement r√©fl√©chi sur les couleurs, <br>
    il a √©tudi√© la lumi√®re, les pigments, la peinture, la psychologie‚Ä¶ <br>
    <br>
    Et il a √©crit sa ¬´ Th√©orie des couleurs ¬ª, un ensemble vaste d‚Äôid√©es et de r√©flexions. <br>
    Il y a dessin√© un diagramme particulier, une intuition <br> 
    <br> 
    ‚ûî la signification possible des couleurs.<br>;

    lang1Code: en;
    lang2Code: fr;
    buttonLabel1: Enter;
    buttonLabel2: Entrer;
    loadingText1: Chargement des √©l√©ments‚Ä¶;
    loadingText2: Loading assets‚Ä¶;">

  <a-assets>

  <img id="line" src="assets/goethe-colors/Line.png">

    <a-asset-item id="env" src="assets/goethe-colors/env-goethe.glb"></a-asset-item>
    <a-asset-item id="navmesh" src="assets/goethe-colors/navmesh-env.glb"></a-asset-item>
    <a-asset-item id="table" src="assets/goethe-colors/table.glb"></a-asset-item>
    <img id="diagram" src="assets/goethe-colors/upscale-diagram_png512.png">
    <a-asset-item id="goethe" src="assets/goethe-colors/goethe.glb"></a-asset-item>

    <a-asset-item id="theory-of-color-info" src="assets/goethe-colors/theoryofcolors.glb"></a-asset-item>
    <a-asset-item id="diagram-info" src="assets/goethe-colors/colordiagram.glb"></a-asset-item>
    <a-asset-item id="JW-Goetheinfo" src="assets/goethe-colors/goethe-written.glb"></a-asset-item>
    
    <a-asset-item id="navmesh-blue" src="assets/goethe-colors/navmesh-blue.glb"></a-asset-item>
    <a-asset-item id="navmesh-green" src="assets/goethe-colors/navmesh-green.glb"></a-asset-item>
    <a-asset-item id="navmesh-indigo" src="assets/goethe-colors/navmesh-indigo.glb"></a-asset-item>
    <a-asset-item id="navmesh-orange" src="assets/goethe-colors/navmesh-orange.glb"></a-asset-item>
    <a-asset-item id="navmesh-red" src="assets/goethe-colors/navmesh-red.glb"></a-asset-item>
    <a-asset-item id="navmesh-yellow" src="assets/goethe-colors/navmesh-yellow.glb"></a-asset-item>

    <a-asset-item id="element-frame" src="assets/goethe-colors/frame-env.glb"></a-asset-item>

    <a-asset-item id="text1" src="assets/goethe-colors/texts-maker/text-JWGoether.glb"></a-asset-item>
    <a-asset-item id="text2" src="assets/goethe-colors/texts-maker/text-diagram.glb"></a-asset-item>
    <a-asset-item id="text3" src="assets/goethe-colors/texts-maker/text-theory.glb"></a-asset-item>

    <a-asset-item id="edel" src="assets/goethe-colors/words compressed/Edel.glb"></a-asset-item>
    <a-asset-item id="gemein" src="assets/goethe-colors/words compressed/Gemein.glb"></a-asset-item>
    <a-asset-item id="gut" src="assets/goethe-colors/words compressed/Gut.glb"></a-asset-item>
    <a-asset-item id="nuztlich" src="assets/goethe-colors/words compressed/Nuztlich.glb"></a-asset-item>
    <a-asset-item id="phantasie" src="assets/goethe-colors/words compressed/phantasie.glb"></a-asset-item>
    <a-asset-item id="schon" src="assets/goethe-colors/words compressed/Schon.glb"></a-asset-item>
    <a-asset-item id="verstand" src="assets/goethe-colors/words compressed/Verstand.glb"></a-asset-item>
    <a-asset-item id="sinnlichkeit" src="assets/goethe-colors/words compressed/sinnlichkeit.glb"></a-asset-item>
    <a-asset-item id="unnothig" src="assets/goethe-colors/words compressed/unnothig.glb"></a-asset-item>
    <a-asset-item id="vernunft" src="assets/goethe-colors/words compressed/Vernunft.glb"></a-asset-item>

    <audio id="bgm" src="assets/goethe-colors/FranzLiszt_Berceuse_D_FlatMajor_174_ScoreToMIDI_CC0_compressed.mp3" preload="auto" loop crossorigin="anonymous"></audio>

  </a-assets>

<!--VR Rig -->
<a-entity id="rig" 
spatial-marker=""
movement-controls="constrainToNavMesh: true ; speed : 0.5; controls: keyboard; enabled:true"  
position="-0.8 0 3.6" rotation="0 -20 0"
simple-navmesh-constraint="navmesh:.navmesh;fall:0;height:0;exclude:.navmesh-hole; "
cursor="rayOrigin: mouse"
raycaster="objects: .clickable">
<a-box camera="far: 700; fov: 55; near: 0.1; active: true" position="0 1.7 0" visible="false" ></a-box>
<a-entity id="left-hand"
  laser-controls="hand: left"
  raycaster="objects: .clickable; far: 6; showLine: false"
  cursor="rayOrigin: entity; fuse: false"
  line="opacity: 0; visible: false">

  <!-- Beam that is occluded normally -->
  <a-entity class="beam beam-occluded"
    laser-beam="length: 0.6; radius: 0.0025; mode: occluded; idleColor: #ffffff; hoverColor: #00ff66; fadeSpeed: 22"
    material="shader: flat; src: #line; transparent: true; opacity: 0.95">
  </a-entity>

  <!-- Beam that never disappears (faint) -->
  <a-entity class="beam beam-xray"
    laser-beam="length: 0.6; radius: 0.0025; mode: xray; idleColor: #ffffff; hoverColor: #00ff66; fadeSpeed: 22"
    material="shader: flat; src: #line; transparent: true; opacity: 0.18">
  </a-entity>
</a-entity>

<a-entity id="right-hand"
  laser-controls="hand: right"
  raycaster="objects: .clickable; far: 6; showLine: false"
  cursor="rayOrigin: entity; fuse: false"
  line="opacity: 0; visible: false">

  <!-- Beam that is occluded normally -->
  <a-entity class="beam beam-occluded"
    laser-beam="length: 0.6; radius: 0.0025; mode: occluded; idleColor: #ffffff; hoverColor: #00ff66; fadeSpeed: 22"
    material="shader: flat; src: #line; transparent: true; opacity: 0.95">
  </a-entity>

  <!-- Beam that never disappears (faint) -->
  <a-entity class="beam beam-xray"
    laser-beam="length: 0.6; radius: 0.0025; mode: xray; idleColor: #ffffff; hoverColor: #00ff66; fadeSpeed: 22"
    material="shader: flat; src: #line; transparent: true; opacity: 0.18">
  </a-entity>
</a-entity>


</a-entity>

</a-entity>

 <!-- Sky -->
<a-sky radius="200" theta-length="110" class="environment" material="shader: skyshader; blending: none; anisotropy: 1.04; turbidity: 20; mieCoefficient: 0.1; mieDirectionalG: 0.72; sunPosition: -0.10389385923870163 0.9444896294427422 0.31168157771610494"></a-sky>
  
<!-- Lights -->
<a-entity light="intensity: 1; type: ambient"></a-entity>
<a-entity light="intensity: 1.884; castShadow: true; shadowBias: -0.0002; shadowCameraFov: 0; shadowCameraNear: -2.47; shadowCameraTop: 8.11; shadowCameraRight: 7.68; shadowCameraBottom: -12.3; shadowCameraLeft: -11.9" position="-0.49743 2.96771 1.19041" data-aframe-default-light="" aframe-injected=""></a-entity>
<a-entity light="intensity: 1.5; type: point" position="0 1.88667 0"></a-entity>

<!-- Scene Environement + nevmesh + shadow hider -->
<a-entity gltf-model="#env" rotation="0 -90 0" position="0 0 0" shadow=""></a-entity>
<a-entity gltf-model="#navmesh" rotation="0 -90 0" position="0 0 0" visible="false" class="navmesh"></a-entity>
<a-entity geometry="primitive: ring; radiusInner: 0.6" rotation="90 -9.55 0" position="0 3.5593 0" scale="6.1595 6.1595 6.1595" shadow="" id="extra-light-hidder"></a-entity>
<a-entity geometry="primitive: ring; radiusInner: 0.6" rotation="90 -9.55 0" position="-0.04525 3.47416 0.02118" scale="3.40291 3.40291 3.40291" shadow="" id="extra-light-hidder-2" material="opacity: 0; side: double; transparent: true"></a-entity>

<!-- Goethe's bust + diagram + table -->  
<a-entity id="goethe-bust" gltf-model="assets/goethe-colors/goethe.glb" rotation="0 -90 0" position="-0.00814 -0.1474 0.01031" shadow="" class="clickable" 
gradient-color="color1: #0841f0; color3: #ff0000; color5: #37005c; color6: #ff4000; colorCount: 4; roughness: 0.7; metalness: 1; speed: 0.7; originalMix: 0.94" 
scale="1.2 1.2 1.2">
</a-entity>

<!-- Diagram plane ‚Üí diagram text -->
 <a-entity id="diagram-element" material="transparent: true; src: #diagram" geometry="primitive: plane" rotation="-90.00021045914971 62.589336582296 0" position="-0.03296 0.81439 0" shimmer-material="shimmerIntensity: 1.5" class="clickable" fade-on-event="targets: #diagram-text; duration: 3; hold: 5; group: goetheTexts"></a-entity>
<a-entity id="diagram-big" material="opacity: 0.6; transparent: true; src: #diagram" geometry="primitive: plane" rotation="-90.00021045914971 62.589336582296 0" position="-0.03296 0.01241 0" class="clickable" scale="9 9 9">
</a-entity>


<a-entity id="element-Goethe" gltf-model="assets/goethe-colors/goethe-written.glb" position="0.38916 1.39795 0" flat-override="opacity: 0.2" fade-on-event="targets: #goethe-text; duration: 3; hold: 5; group: goetheTexts" class="clickable" scale="0.3 0.3 0.3" rotation="0 -90 0"></a-entity>
<a-entity id="element-theory" gltf-model="assets/goethe-colors/theoryofcolors.glb" position="0.43605 1.18089 0" flat-override="opacity: 0.2" fade-on-event="targets: #diagram-text; duration: 3; hold: 5; group: goetheTexts" class="clickable" scale="0.3 0.3 0.3" rotation="0 -90 0"></a-entity>
<a-entity id="element-diagram" gltf-model="assets/goethe-colors/colordiagram.glb" position="0.45782 0.99437 0" flat-override="opacity: 0.2" fade-on-event="targets: #theory-text; duration: 3; hold: 5; group: goetheTexts" class="clickable" scale="0.3 0.3 0.3" rotation="0 -90 0"></a-entity>
<a-entity gltf-model="#table" rotation="0 -90 0" position="0 0 0" visible="true"></a-entity>


<!-- navmeshs x6 -->
<!-- ORANGE -->
<a-entity id="navmesh-orange-element"
          gltf-model="#navmesh-orange"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-orange-area; zone: orange; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- BLUE -->
<a-entity id="navmesh-blue-element"
          gltf-model="#navmesh-blue"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-blue-area; zone: blue; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- RED -->
<a-entity id="navmesh-red-element"
          gltf-model="#navmesh-red"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-red-area; zone: red; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- YELLOW -->
<a-entity id="navmesh-yellow-element"
          gltf-model="#navmesh-yellow"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-yellow-area; zone: yellow; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- GREEN -->
<a-entity id="navmesh-green-element"
          gltf-model="#navmesh-green"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-green-area; zone: green; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- VIOLET / INDIGO -->
<a-entity id="navmesh-indigo-element"
          gltf-model="#navmesh-indigo"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-violet-area; zone: indigo; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>


<!-- drawing space elements -->
<!-- Orange Area -->
<a-entity id="element-orange-area" 
gltf-model="assets/goethe-colors/frame-env.glb" 
position="0 1.56005 -6.24316" gradient-color="color1: #ffffff; color2: #fff1e5; opacity: 0; roughness: 0; metalness: 1" scale="0.5 0.5 0.5">
</a-entity>

<!-- Blue Area -->
<a-entity id="element-blue-area" 
gltf-model="assets/goethe-colors/frame-env.glb" 
rotation="0 -180 0" position="0 1.47372 6.31276" 
gradient-color="color1: #ffffff; color2: #b6c1cd; opacity: 0; roughness: 0" scale="0.5 0.5 0.5">
</a-entity>

<!-- Red Area -->
<a-entity id="element-red-area" gltf-model="assets/goethe-colors/frame-env.glb" 
rotation="0 62.931965343784235 90.00021045914971" position="-5.36705 1.47327 -2.98325" 
gradient-color="color1: #ffffff; color2: #fff5f5; opacity: 0.1" scale="0.4 0.4 0.4">
</a-entity>

<!-- Yellow Area -->
<a-entity id="element-yellow-area" 
gltf-model="assets/goethe-colors/frame-env.glb" 
rotation="0 -62 -90" position="5.43597 1.52474 -3.13707" 
gradient-color="color1: #ffffff; color2: #eae6d2; opacity: 0; roughness: 0; metalness: 1" scale="0.4 0.4 0.4">
</a-entity>

<!-- Green Area -->
<a-entity id="element-green-area" 
gltf-model="assets/goethe-colors/frame-env.glb" rotation="0 -119.01593912016487 0" 
position="5.44141 1.79871 2.94187" gradient-color="color1: #ffffff; color2: #f0fff0; opacity: 0" scale="0.9 0.9 0.9">
</a-entity>



<!-- Marker-Texts -->
<a-entity id="goethe-text" gltf-model="#text1" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>
<a-entity id="diagram-text" gltf-model="#text2" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>
<a-entity id="theory-text" gltf-model="#text3" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>


<a-entity id="edel" gltf-model="#edel" position="-0.37194 2.28755 -6.13326" flat-override="opacity: 0.52" scale="0.75 0.75 0.75"></a-entity>
<a-entity id="gut" gltf-model="#gut" position="5.49982 2.42192 -3.10054" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 -71.5990979107282 0"></a-entity>
<a-entity id="nuztlich" gltf-model="#nuztlich" position="4.97181 2.28755 2.96997" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 -126.8201972476418 0"></a-entity>
<a-entity id="gemein" gltf-model="#gemein" position="-0.10445 2.28755 6.31301" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 180 0"></a-entity>
<a-entity id="unnothig" gltf-model="#unnothig" position="-5.21878 2.28755 3.2757" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 126.22317522511548 0"></a-entity>
<a-entity id="schon" gltf-model="#schon" position="-5.45174 2.28755 -3.07225" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 60.677376419944444 0"></a-entity>
<a-entity id="verstand" gltf-model="#verstand" position="3.23791 -0.03986 -0.62757" flat-override="opacity: 0.2" rotation="-53.44607608759832 -70.61074571412753 0"></a-entity>
<a-entity id="sinnlichkeit" gltf-model="#sinnlichkeit" position="1.12832 0.17646 2.8613" flat-override="opacity: 0.2" rotation="-52.5980985508047 -158.30422809008053 4.646687718510977"></a-entity>
<a-entity id="phantasie" gltf-model="#phantasie" position="-3.18411 0.25267 0.40501" flat-override="opacity: 0.2" rotation="-70.0079941136499 94.2475465944545 11.106213900815877"></a-entity>
<a-entity id="vernunft" gltf-model="#vernunft" position="-1.32109 0.22329 -2.73259" flat-override="opacity: 0.2" rotation="-65.7698253030672 21.4790418238643 8.341692539309655"></a-entity>

</a-scene>

  </body>
</html>
