<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Goethe's Theory of Colours</title>
    <meta name="description" content="A demo of the Spatial-Marker component">
    
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://rpetitjean.github.io/spatial-marker/spatial-marker.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AdaRoseCannon/aframe-xr-boilerplate/simple-navmesh-constraint.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.5.x/dist/aframe-environment-component.min.js"></script>
    <script src="animate-gradient.js"></script>

    <script src="intro-overlay.js" ></script>

<!-- Fades in glb models when the user is in a defined color zone -->
  <script>
AFRAME.registerComponent('area-fade-gradient', {
  schema: {
    target:     { type: 'selector' },         // GLB with gradient-color
    zone:       { type: 'string' },           // 'orange', 'blue', etc
    maxOpacity: { type: 'number', default: 1 },   // when this zone is active
    minOpacity: { type: 'number', default: 0.1 }, // otherwise
    speed:      { type: 'number', default: 2 }    // fade speed (per second)
  },

  init: function () {
    const data   = this.data;
    this.active  = false;
    this.currentOpacity = data.minOpacity;
    this.targetOpacity  = data.minOpacity;

    const sceneEl = this.el.sceneEl;
    this.onZoneChanged = (e) => {
      const activeName = e.detail && e.detail.name;
      this.active = (activeName === data.zone);
    };

    if (sceneEl) {
      sceneEl.addEventListener('goethe-zone-changed', this.onZoneChanged);
    }
  },

  remove: function () {
    const sceneEl = this.el.sceneEl;
    if (sceneEl && this.onZoneChanged) {
      sceneEl.removeEventListener('goethe-zone-changed', this.onZoneChanged);
    }
  },

  tick: function (time, dt) {
    const targetEl = this.data.target;
    if (!targetEl) return;

    // Set target opacity based on zone activity
    this.targetOpacity = this.active ? this.data.maxOpacity : this.data.minOpacity;

    // Smooth fade
    const dtSec      = dt / 1000;
    const lerpFactor = 1.0 - Math.exp(-this.data.speed * dtSec);
    this.currentOpacity = THREE.MathUtils.lerp(
      this.currentOpacity,
      this.targetOpacity,
      lerpFactor
    );

    // Apply opacity to target's gradient-color shader
    const mesh = targetEl.getObject3D('mesh');
    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material || !node.material.uniforms) return;
      if (node.material.uniforms.opacity) {
        node.material.uniforms.opacity.value = this.currentOpacity;
      }
    });

    // Toggle visibility for perf
    targetEl.setAttribute('visible', this.currentOpacity > 0.01);
  }

  
});

  </script>

<!-- Fade on Event: fades-in and out the three info texts when clicking a defined object-->
<script>
AFRAME.registerComponent('fade-on-event', {
  schema: {
    targets:      { type: 'string' },           // CSS selector: "#goethe-text, .caption"
    event:        { type: 'string', default: 'click' },
    duration:     { type: 'number', default: 2 },   // fade in/out duration (seconds)
    from:         { type: 'number', default: 0 },   // hidden opacity
    to:           { type: 'number', default: 1 },   // visible opacity
    delay:        { type: 'number', default: 0 },   // delay before fade-in (seconds)
    hold:         { type: 'number', default: 0 },   // time fully visible before fade-out (0 = no auto fade-out)
    once:         { type: 'boolean', default: false }, // if true: only first full cycle
    autoInit:     { type: 'boolean', default: true },  // hide targets at init
    group:        { type: 'string',  default: '' }     // group name for mutual exclusion
  },

  init: function () {
    this.targets = [];

    // state machine: 'idle' | 'delay' | 'fadeIn' | 'hold' | 'fadeOut'
    this.state = 'idle';
    this.timer = 0;
    this._alreadyTriggered = false;
    this.lastOpacity = this.data.from;
    this.fadeStartOpacity = this.data.from;

    this._updateTargetList();

    if (this.data.autoInit) {
      this._hideTargetsImmediately();
    }

    if (this.data.event === 'click') {
      this.el.classList.add('clickable');
    }

    this._onEvent = this._onEvent.bind(this);
    this._onGlobalFadeStart = this._onGlobalFadeStart.bind(this);

    this.el.addEventListener(this.data.event, this._onEvent);

    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl) {
      sceneEl.addEventListener('fade-on-event-started', this._onGlobalFadeStart);
    }
  },

  remove: function () {
    this.el.removeEventListener(this.data.event, this._onEvent);
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl) {
      sceneEl.removeEventListener('fade-on-event-started', this._onGlobalFadeStart);
    }
  },

  update: function (oldData) {
    if (!oldData || oldData.targets !== this.data.targets) {
      this._updateTargetList();
      if (this.data.autoInit) {
        this._hideTargetsImmediately();
      }
    }
  },

  _updateTargetList: function () {
    const sel = this.data.targets;
    if (!sel) {
      this.targets = [];
      return;
    }
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (!sceneEl) {
      this.targets = [];
      return;
    }
    this.targets = Array.from(sceneEl.querySelectorAll(sel));
  },

  _hideTargetsImmediately: function () {
    this.targets.forEach((el) => {
      el.setAttribute('visible', false);
      el.addEventListener('model-loaded', () => {
        this._setOpacityOnMesh(el, this.data.from);
      });
    });
  },

  _onEvent: function () {
    // Ignore if an animation is already running
    if (this.state !== 'idle') return;

    // If single-use and already did one full cycle, ignore
    if (this.data.once && this._alreadyTriggered) return;

    // Announce to the group that THIS one is starting
    const sceneEl = this.el.sceneEl || document.querySelector('a-scene');
    if (sceneEl && this.data.group) {
      sceneEl.emit('fade-on-event-started', {
        group: this.data.group,
        source: this.el
      });
    }

    this._alreadyTriggered = true;
    this.timer = 0;

    if (this.data.delay > 0) {
      this.state = 'delay';
    } else {
      this.state = 'fadeIn';
      this.fadeStartOpacity = this.data.from;
    }

    this._setOpacityAll(this.data.from);
  },

  // When another member of the same group starts, fade THIS one out
  _onGlobalFadeStart: function (e) {
    const detail = e.detail || {};
    const group = detail.group;
    const source = detail.source;

    if (!group || group !== this.data.group) return;
    if (source === this.el) return; // that's us, ignore

    // If currently idle and already at "from", nothing to do
    if (this.state === 'idle' && this.lastOpacity <= this.data.from + 0.001) {
      return;
    }

    // Start a smooth fade-out from current opacity → from
    this.state = 'fadeOut';
    this.timer = 0;
    this.fadeStartOpacity = this.lastOpacity;
  },

  _setOpacityAll: function (value) {
    this.lastOpacity = value;
    this.targets.forEach((el) => this._setOpacityOnMesh(el, value));
  },

  _setOpacityOnMesh: function (el, value) {
    const v = THREE.MathUtils.clamp(value, 0, 1);
    const mesh = el.getObject3D('mesh');

    el.setAttribute('visible', v > 0.01);

    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material) return;
      const mats = Array.isArray(node.material) ? node.material : [node.material];

      mats.forEach((mat) => {
        if (!mat) return;

        mat.transparent = true;
        mat.opacity = v;
        mat.needsUpdate = true;

        if (mat.uniforms && mat.uniforms.opacity) {
          mat.uniforms.opacity.value = v;
        }
      });
    });
  },

  tick: function (time, dt) {
    if (this.state === 'idle' || this.targets.length === 0) return;

    const dtSec = dt / 1000;
    const data  = this.data;
    const dur   = Math.max(data.duration, 0.0001);

    this.timer += dtSec;

    switch (this.state) {
      case 'delay': {
        if (this.timer >= data.delay) {
          this.state = 'fadeIn';
          this.fadeStartOpacity = data.from;
          this.timer = 0;
        }
        break;
      }

      case 'fadeIn': {
        const p = Math.min(this.timer / dur, 1);
        const v = THREE.MathUtils.lerp(this.fadeStartOpacity, data.to, p);
        this._setOpacityAll(v);

        if (p >= 1) {
          this.timer = 0;
          if (data.hold > 0) {
            this.state = 'hold';
          } else {
            this.state = 'idle';
          }
        }
        break;
      }

      case 'hold': {
        if (this.timer >= data.hold) {
          this.state = 'fadeOut';
          this.fadeStartOpacity = this.lastOpacity; // should be ~data.to
          this.timer = 0;
        }
        break;
      }

      case 'fadeOut': {
        const p = Math.min(this.timer / dur, 1);
        const v = THREE.MathUtils.lerp(this.fadeStartOpacity, data.from, p);
        this._setOpacityAll(v);

        if (p >= 1) {
          this.state = 'idle';
        }
        break;
      }
    }
  }
});

</script>

<!-- Export Scene Module: export scene with lines in VR Mode-->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.173.0/build/three.module.js';
  import { GLTFExporter } from 'https://unpkg.com/three@0.173.0/examples/jsm/exporters/GLTFExporter.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.173.0/examples/jsm/controls/OrbitControls.js';

  // ---------- helpers ----------
  const tsName = (prefix='spatial-marker')=>{
    const t=new Date(), pad=n=>(n<10?'0':'')+n;
    return `${prefix}_${t.getFullYear()}${pad(t.getMonth()+1)}${pad(t.getDate())}_${pad(t.getHours())}${pad(t.getMinutes())}${pad(t.getSeconds())}.glb`;
  };
  const syncWorld = (root)=>{ try{ root.updateMatrixWorld(true); }catch(_){} };

  // ---------- Blender-safe guards (hide risky nodes + sanitize geometry) ----------
  function makeBlenderSafeGuards(root){
    const hidden = [];
    // Hide A-Frame UI / texture-driven nodes (controllers, hint planes, any [src], etc.)
    const selectors = [
      '#left-hand', '#right-hand', '.drawingArea',
      '[src]', '[material*="src:"]'
    ];
    selectors.forEach(sel=>{
      document.querySelectorAll(sel).forEach(el=>{
        const o = el?.object3D;
        if (o && o.visible) { hidden.push([o, o.visible]); o.visible = false; }
      });
    });

    // Hide meshes with texture maps; sanitize geometry numbers; ensure indices/normals.
    root.traverse(o=>{
      if (!o.isMesh) return;
      // Hide textured meshes so we don't embed CORS-tainted images.
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      if (mats.some(m => m && (m.map || m.emissiveMap || m.roughnessMap || m.metalnessMap || m.normalMap))) {
        hidden.push([o, o.visible]); o.visible = false; return;
      }

      const g = o.geometry;
      if (!g || !g.isBufferGeometry) return;

      // Drop invalid or empty
      const pos = g.getAttribute('position');
      if (!pos || pos.count < 3) { hidden.push([o, o.visible]); o.visible = false; return; }

      // Clamp drawRange and clean NaN/Inf in attributes
      g.setDrawRange(0, pos.count);
      ['position','normal','uv','color'].forEach(name=>{
        const a = g.getAttribute(name);
        if (!a) return;
        let dirty = false;
        const arr = a.array;
        for (let i=0;i<arr.length;i++){
          const v = arr[i];
          if (!Number.isFinite(v)) { arr[i] = 0; dirty = true; }
        }
        if (dirty) a.needsUpdate = true;
      });
      if (!g.getAttribute('normal') || !g.getAttribute('normal').count) {
        try { g.computeVertexNormals(); } catch(_){}
      }
      // Ensure indexed geometry (Blender is happier with indices).
      if (!g.index) {
        try { g.setIndex([...Array(pos.count).keys()]); } catch(_){}
      }
    });

    // restore fn
    return ()=>hidden.forEach(([o, v])=>{ o.visible = v; });
  }

  // ---------- floating window viewer (unchanged, with robust close) ----------
  function openFloatingWindowWithBlob(blob, filename){
    const url = URL.createObjectURL(blob);

    if (!document.getElementById('glb-fwin-css')) {
      const style = document.createElement('style');
      style.id = 'glb-fwin-css';
      style.textContent = `
        .glb-fwin{position:fixed;top:6vh;left:6vw;width:70vw;height:70vh;background:#0b0d10;border:1px solid #334155;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);display:flex;flex-direction:column;z-index:99999;overflow:hidden; font-family: system-ui, Segoe UI, Arial;}
        .glb-fwin-header{display:flex;gap:8px;align-items:center;background:#111827;color:#e5e7eb;padding:8px 10px;user-select:none}
        .glb-fwin-title{font:600 14px/1 system-ui, Segoe UI, Arial; color:#e5e7eb}
        .glb-fwin-spacer{flex:1}
        .glb-fwin-btn{padding:6px 10px;border-radius:8px;background:#1f2937;border:1px solid #334155;color:#e5e7eb;text-decoration:none;cursor:pointer}
        .glb-fwin-btn:hover{background:#0f172a}
        .glb-fwin-body{position:relative;flex:1;min-height:0}
        .glb-fwin-body canvas{display:block;width:100%;height:100%}
        .glb-fwin-resize{position:absolute;right:0;bottom:0;width:18px;height:18px;cursor:nwse-resize;background:linear-gradient(135deg,transparent 50%,#334155 50%)}
      `;
      document.head.appendChild(style);
    }

    const frame = document.createElement('div'); frame.className = 'glb-fwin';
    const header = document.createElement('div'); header.className = 'glb-fwin-header';
    const title = document.createElement('div'); title.className = 'glb-fwin-title'; title.textContent = filename;
    const spacer = document.createElement('div'); spacer.className = 'glb-fwin-spacer';
    const btnDL  = document.createElement('a');  btnDL.className='glb-fwin-btn'; btnDL.textContent='⬇️ Download'; btnDL.href=url; btnDL.download=filename;
    const btnExt = document.createElement('a');  btnExt.className='glb-fwin-btn'; btnExt.textContent='↗︎ About this viewer'; btnExt.href='https://github.com/donmccurdy/three-gltf-viewer'; btnExt.target='_blank'; btnExt.rel='noopener';
    const btnClose = document.createElement('button'); btnClose.className='glb-fwin-btn'; btnClose.textContent='✕'; btnClose.type='button';
    btnClose.style.minWidth = '44px'; btnClose.style.minHeight = '34px';
    header.append(title, spacer, btnDL, btnExt, btnClose);

    const body = document.createElement('div'); body.className = 'glb-fwin-body';
    const resizeHandle = document.createElement('div'); resizeHandle.className = 'glb-fwin-resize';
    body.appendChild(resizeHandle);
    frame.append(header, body);
    document.body.appendChild(frame);

    // Drag (ignore clicks on buttons)
 let dragging=false, dragSX=0, dragSY=0, ox=0, oy=0, pid=null;

    header.addEventListener('pointerdown', e=>{
      if (e.button!==0) return;
      if (e.target.closest('.glb-fwin-btn')) return;
 dragging=true; pid=e.pointerId; dragSX=e.clientX; dragSY=e.clientY;
  const r=frame.getBoundingClientRect(); ox=r.left; oy=r.top;
  header.setPointerCapture(pid);
    });
    header.addEventListener('pointermove', e=>{
  if (!dragging || e.pointerId!==pid) return;
  const nx=Math.max(0,Math.min(window.innerWidth-frame.offsetWidth,  ox+(e.clientX-dragSX)));
  const ny=Math.max(0,Math.min(window.innerHeight-frame.offsetHeight, oy+(e.clientY-dragSY)));
  frame.style.left=nx+'px'; frame.style.top=ny+'px';
    });
    header.addEventListener('pointerup', e=>{
      if (e.pointerId!==pid) return;
      dragging=false; try{ header.releasePointerCapture(pid);}catch(_){}
      pid=null;
    });
    [btnDL,btnExt,btnClose].forEach(el=>el.addEventListener('pointerdown', e=>e.stopPropagation(), {passive:true}));

    // Resize
    let resizing=false, rsId=null, resSX=0, resSY=0, sw=0, sh=0;

   resizeHandle.addEventListener('pointerdown', e=>{ rsId=e.pointerId; resizing=true; resSX=e.clientX; resSY=e.clientY; sw=frame.offsetWidth; sh=frame.offsetHeight; resizeHandle.setPointerCapture(rsId); });
resizeHandle.addEventListener('pointermove', e=>{
  if (!resizing || e.pointerId!==rsId) return;
  const nw=Math.max(360, sw+(e.clientX-resSX));
  const nh=Math.max(240, sh+(e.clientY-resSY));
  frame.style.width=nw+'px'; frame.style.height=nh+'px';
  onResize();
});

    resizeHandle.addEventListener('pointerup', e=>{ if (e.pointerId!==rsId) return; resizing=false; try{ resizeHandle.releasePointerCapture(rsId);}catch(_){ } rsId=null; });

    // Three viewer
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    body.appendChild(renderer.domElement);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0d10);
    const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 1000); camera.position.set(1.8,1.2,2.2);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
    scene.add(new THREE.HemisphereLight(0xffffff, 0x202020, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,7); scene.add(dir);
    const grid = new THREE.GridHelper(10,10,0x335577,0x223344); grid.material.opacity=0.35; grid.material.transparent=true; scene.add(grid);

    (async ()=>{
      const { GLTFLoader } = await import('https://unpkg.com/three@0.173.0/examples/jsm/loaders/GLTFLoader.js');
      new GLTFLoader().load(url, (gltf)=>{
        const root = gltf.scene || gltf.scenes?.[0];
        scene.add(root);
        const box = new THREE.Box3().setFromObject(root);
        const size = box.getSize(new THREE.Vector3()).length() || 1;
        const center = box.getCenter(new THREE.Vector3());
        controls.target.copy(center);
        camera.position.copy(center).add(new THREE.Vector3(0.5, size*0.4, size*0.8));
        camera.near=size/1000; camera.far=size*10; camera.updateProjectionMatrix();
      });
    })();

    function onResize(){
      const w = body.clientWidth, h = body.clientHeight;
      camera.aspect = Math.max(1e-6, w / Math.max(1, h));
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }
    const ro = new ResizeObserver(onResize); ro.observe(body); onResize();
    renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene, camera); });

    // Close
    function doClose(){
      try { renderer.setAnimationLoop(null); } catch(_){}
      try { ro.disconnect(); } catch(_){}
      try { URL.revokeObjectURL(url); } catch(_){}
      frame.remove();
      document.removeEventListener('keydown', onEsc, true);
    }
    const onEsc = (e)=>{ if (e.key==='Escape'){ e.stopPropagation(); e.preventDefault(); doClose(); } };
    document.addEventListener('keydown', onEsc, true);
    btnClose.addEventListener('click', e=>{ e.preventDefault(); e.stopPropagation(); doClose(); });
    btnClose.addEventListener('keydown', e=>{ if (e.key==='Enter'||e.key===' '){ e.preventDefault(); doClose(); } });
  }

  // ---------- export (normal vs blender-safe) ----------
  const REGULAR_OPTS = { binary:true, onlyVisible:true, embedImages:true };
  const BLENDER_OPTS = { binary:true, onlyVisible:true, embedImages:true, includeCustomExtensions:false, forceIndices:true, truncateDrawRange:true };

  async function exportToFloatingWindow(rootObj3D, {blenderSafe=false}={}){
    // Leave VR so window is visible on headset
    const sceneEl = document.querySelector('a-scene');
    if (sceneEl?.is('vr-mode')) { try { await sceneEl.exitVR(); } catch(_){} }

    syncWorld(rootObj3D);
    const exporter = new GLTFExporter();
    const filename = tsName(blenderSafe ? 'spatial-marker_blender' : 'spatial-marker');

    let restore = ()=>{};
    if (blenderSafe) restore = makeBlenderSafeGuards(rootObj3D);

    exporter.parse(
      rootObj3D,
      (ab)=>{
        restore();
        const blob = new Blob([ab], { type: 'model/gltf-binary' });
        openFloatingWindowWithBlob(blob, filename);
      },
      (err)=>{ restore(); console.warn('[export] failed:', err); },
      blenderSafe ? BLENDER_OPTS : REGULAR_OPTS
    );
  }

  // ---------- triggers ----------
  // Desktop:
  window.addEventListener('keydown', (e)=>{
    if (e.repeat) return;
    const k = (e.key||'').toLowerCase();
    if (k === 'e' || k === 'b') {
      e.preventDefault();
      const scene = document.querySelector('a-scene')?.object3D;
      if (!scene) return;
      exportToFloatingWindow(scene, { blenderSafe: k === 'b' });
    }
  });

  // VR dual-grip → Blender-safe
  const HOLD_MS = 600;
  const left  = document.getElementById('left-hand');
  const right = document.getElementById('right-hand');
  const state = { left:false, right:false, timer:null, cooldown:false };

  function tryStartTimer(){
    if (state.timer || state.cooldown) return;
    if (state.left && state.right){
      state.timer = setTimeout(()=>{
        state.timer = null;
        if (state.left && state.right){
          state.cooldown = true; setTimeout(()=> state.cooldown=false, 1200);
          const scene = document.querySelector('a-scene')?.object3D;
          if (scene) exportToFloatingWindow(scene, { blenderSafe:true });
        }
      }, HOLD_MS);
    }
  }
  function onPress(e){ const s=(e.currentTarget===left)?'left':'right'; state[s]=true; tryStartTimer(); }
  function onRelease(e){ const s=(e.currentTarget===left)?'left':'right'; state[s]=false; if(state.timer){ clearTimeout(state.timer); state.timer=null; } }

  ['gripdown','squeezestart'].forEach(ev=>{ left?.addEventListener(ev,onPress); right?.addEventListener(ev,onPress); });
  ['gripup','squeezeend'  ].forEach(ev=>{ left?.addEventListener(ev,onRelease); right?.addEventListener(ev,onRelease); });
</script>

<!-- Shimmer Material : effect use to animate the 6 color diagram -->
<script>
AFRAME.registerComponent('shimmer-material', {
  schema: {
    opacity:          { type: 'number', default: 1.0 },
    shimmerIntensity: { type: 'number', default: 1.0 }, // how strong the shimmer is
    shimmerSpeed:     { type: 'number', default: 1.0 }  // how fast it moves
  },

  init: function () {
    this.shaderMaterials = [];
    this.applyMaterial = this.applyMaterial.bind(this);

    this.el.addEventListener('loaded', this.applyMaterial);
    this.el.addEventListener('model-loaded', this.applyMaterial);
    this.el.addEventListener('materialtextureloaded', this.applyMaterial);

    this.applyMaterial();
  },

  makeShaderMaterial: function (baseMap) {
    const data = this.data;
    baseMap.wrapS = baseMap.wrapT = THREE.ClampToEdgeWrapping;

    return new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        time:            { value: 0 },
        opacity:         { value: data.opacity },
        shimmerIntensity:{ value: data.shimmerIntensity },
        shimmerSpeed:    { value: data.shimmerSpeed },
        baseMap:         { value: baseMap }
      },

      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,

      fragmentShader: `
        uniform float time;
        uniform float opacity;
        uniform float shimmerIntensity;
        uniform float shimmerSpeed;
        uniform sampler2D baseMap;
        varying vec2 vUv;

        // very simple 2D noise
        float random(vec2 st) {
          return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453);
        }
        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));

          vec2 u = f * f * (3.0 - 2.0 * f);

          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        void main() {
          vec4 baseSample = texture2D(baseMap, vUv);
          if (baseSample.a < 0.01) {
            discard;
          }

          // animated noise over the whole plane
          vec2 st = vUv * 4.0;
          st += vec2(time * shimmerSpeed * 0.2, -time * shimmerSpeed * 0.17);

          float n = noise(st);        // 0..1
          n = clamp(n, 0.0, 1.0);

          // brightness deviation around 1.0 (e.g. 0.5..1.5)
          float amp = 0.5 * shimmerIntensity;
          float brightness = 1.0 + (n - 0.5) * 2.0 * amp;

          // build a white “boost” so highlights go to white, not grey
          vec3 whiteBoost = mix(vec3(0.0), vec3(1.0), max(0.0, brightness - 1.0));

          // add white highlight on top of original color
          vec3 finalRGB = baseSample.rgb + whiteBoost * 0.85;
          finalRGB = clamp(finalRGB, 0.0, 1.0);

          // slight alpha variation
          float alphaFactor = 1.0 + (n - 0.5) * 0.4 * shimmerIntensity;
          float finalA = baseSample.a * opacity * alphaFactor;
          finalA = clamp(finalA, 0.0, 1.0);

          gl_FragColor = vec4(finalRGB, finalA);
        }
      `
    });
  },

  applyMaterial: function () {
    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;

    const list = this.shaderMaterials;

    mesh.traverse((node) => {
      if (!node.isMesh) return;
      const oldMat = node.material;

      if (Array.isArray(oldMat)) {
        const newMats = [];
        for (let i = 0; i < oldMat.length; i++) {
          const m = oldMat[i];
          if (!m || !m.map) { newMats.push(m); continue; }
          const sm = this.makeShaderMaterial(m.map);
          newMats.push(sm);
          list.push(sm);
        }
        node.material = newMats;
      } else {
        if (!oldMat || !oldMat.map) return;
        const sm = this.makeShaderMaterial(oldMat.map);
        node.material = sm;
        list.push(sm);
      }
    });
  },

  tick: function (timeMs) {
    const t = timeMs / 1000.0;
    for (let i = 0; i < this.shaderMaterials.length; i++) {
      const m = this.shaderMaterials[i];
      if (m.uniforms.time) m.uniforms.time.value = t;
    }
  }
});
</script>

<!-- Goethe Zones script, react to rig's position in the 6 different color zones to set up the colour palette -->
<script>
AFRAME.registerComponent('goethe-zones', {
  schema: {
    rig: {type: 'selector', default: '#rig'}
  },

  init: function () {
    // the rig (where spatial-marker is)
    this.rig = this.data.rig || document.querySelector('#rig');
    this.currentZone = null;
    this._rigPos = new THREE.Vector3();

    // Define your 24-color palettes here
    // (put whatever 24 hex colors you want for each main color)
this.palettes = {
  blue: [
        '#081427','#3572ee','#0b1a33','#3a7aff',
        '#0f2244','#4584ff','#132a55','#4f8eff',
        '#163266','#5998ff','#193a77','#63a2ff',
        '#1d4288','#6dacff','#214a99','#77b6ff',
        '#2552aa','#81c0ff','#295abb','#8bcaFF',
        '#2d62cc','#95d4ff','#316add','#9fdeff'
  ],
  green: [
        '#06210f','#36ca63','#0a2f16','#3ad86a',
        '#0e3d1d','#3fe672','#124c24','#49ec7a',
        '#165a2b','#54f283','#1a6832','#5ff88b',
        '#1e7639','#6aff94','#228440','#75ff9d',
        '#269247','#80ffa6','#2aa04e','#8bffaf',
        '#2eae55','#96ffb8','#32bc5c','#a1ffc1'
  ],
  indigo: [
        '#130827','#6737b7','#1a0b33','#6e3bc3',
        '#210f3f','#7540cf','#28134b','#7c44db',
        '#2f1757','#8348e7','#361b63','#8a4cf3',
        '#3d1f6f','#9150ff','#44237b','#9b5aff',
        '#4b2787','#a564ff','#522b93','#af6eff',
        '#592f9f','#b978ff','#6033ab','#c382ff'
  ],
  orange: [
        '#2b1304','#ea7217','#3a1a05','#fa7a19',
        '#4a2206','#ff8423','#5a2a07','#ff8f35',
        '#6a3208','#ff9a47','#7a3a09','#ffa559',
        '#8a420b','#ffb06b','#9a4a0d','#ffbb7d',
        '#aa520f','#ffc68f','#ba5a11','#ffd1a1',
        '#ca6213','#ffdcb3','#da6a15','#ffe7c5'
  ],
  red: [
        '#2b0404','#ea1717','#3a0505','#fa1919',
        '#4a0606','#ff2323','#5a0707','#ff3535',
        '#6a0808','#ff4747','#7a0909','#ff5959',
        '#8a0b0b','#ff6b6b','#9a0d0d','#ff7d7d',
        '#aa0f0f','#ff8f8f','#ba1111','#ffa1a1',
        '#ca1313','#ffb3b3','#da1515','#ffc5c5'
  ],
  yellow: [
        '#3f3300','#f9cc00','#514000','#ffd11a',
        '#635000','#ffd633','#756000','#ffdb4d',
        '#877000','#ffe066','#998000','#ffe580',
        '#ab9000','#ffea99','#b89a00','#ffefb3',
        '#c5a400','#fff4cc','#d2ae00','#fff9e6',
        '#dfb800','#fffaf0','#ecc200','#fffdf7'
  ]
};


    // Navmesh zones for each Goethe color
    this.zones = [
      {name: 'blue',   el: document.querySelector('[gltf-model="#navmesh-blue"]'),   box: null},
      {name: 'green',  el: document.querySelector('[gltf-model="#navmesh-green"]'),  box: null},
      {name: 'indigo', el: document.querySelector('[gltf-model="#navmesh-indigo"]'), box: null},
      {name: 'orange', el: document.querySelector('[gltf-model="#navmesh-orange"]'), box: null},
      {name: 'red',    el: document.querySelector('[gltf-model="#navmesh-red"]'),    box: null},
      {name: 'yellow', el: document.querySelector('[gltf-model="#navmesh-yellow"]'), box: null}
    ];
  },

  tick: function () {
    const rig = this.rig;
    if (!rig || !rig.object3D) return;

    // rig world position
    rig.object3D.getWorldPosition(this._rigPos);

    let activeZone = null;

    for (const z of this.zones) {
      if (!z.el) continue;
      const mesh = z.el.getObject3D('mesh') || z.el.object3D;
      if (!mesh) continue;

      // build bounding box once
      if (!z.box) {
        z.box = new THREE.Box3().setFromObject(mesh);
      }

      if (z.box.containsPoint(this._rigPos)) {
        activeZone = z;
        break;
      }
    }

    // no change → nothing to do
    if (activeZone === this.currentZone) return;

    // tell the whole scene which zone is active
    const name = activeZone ? activeZone.name : null;
    this.el.emit('goethe-zone-changed', { name });

    // if we have a new active zone, push its palette into spatial-marker
    if (activeZone && this.palettes[activeZone.name]) {
      const palette = this.palettes[activeZone.name];
      const value = palette.join(',');
      rig.setAttribute('spatial-marker', 'colors', value);
      console.log('[goethe-zones] active zone:', activeZone.name);
    }

    this.currentZone = activeZone;
  }
});

</script>

<script>
AFRAME.registerComponent('flat-override', {
  schema: {
    color:   { type: 'color',  default: '#ffffff' },
    opacity: { type: 'number', default: 1 }
  },

  init() {
    this.el.addEventListener('model-loaded', () => {
      const mesh = this.el.getObject3D('mesh');
      if (!mesh) return;

      mesh.traverse((node) => {
        if (!node.isMesh) return;

        node.material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(this.data.color),
          transparent: this.data.opacity < 1,
          opacity: this.data.opacity,
          roughness: 0.8,
          metalness: 0
        });

        node.material.needsUpdate = true;
      });
    });
  },

  update() {
    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;

    mesh.traverse((node) => {
      if (!node.isMesh || !node.material) return;

      node.material.color.set(this.data.color);
      node.material.opacity = this.data.opacity;
      node.material.transparent = this.data.opacity < 1;
    });
  }
});
</script>

<script>
/* --- Gradient-textured laser shader (uses your #line texture) --- */
AFRAME.registerShader('laser-gradient', {
  schema: {
    src:      { type: 'map' },
    color:    { type: 'color', default: '#111111' },
    opacity:  { type: 'number', default: 1.0 },
    emissive: { type: 'number', default: 1.0 }
  },

  init: function (data) {
    this.material = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide,
      uniforms: {
        map:     { value: data.src || null },
        tint:    { value: new THREE.Color(data.color) },
        opacity: { value: data.opacity },
        emissive:{ value: data.emissive }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        uniform vec3 tint;
        uniform float opacity;
        uniform float emissive;
        varying vec2 vUv;

        void main(){
          vec4 t = texture2D(map, vUv);

          // Extra soft fade near the "tip" (vUv.y ~ 1 on cylinder height)
          float tipFade = smoothstep(1.0, 0.75, vUv.y);

          float a = t.a * opacity * tipFade;
          if (a < 0.01) discard;

          vec3 rgb = (t.rgb * tint) * emissive;
          gl_FragColor = vec4(rgb, a);
        }
      `
    });
  },

  update: function (data) {
    if (!this.material) return;
    if (data.src) this.material.uniforms.map.value = data.src;
    this.material.uniforms.tint.value.set(data.color);
    this.material.uniforms.opacity.value = data.opacity;
    this.material.uniforms.emissive.value = data.emissive;
    this.material.needsUpdate = true;
  }
});


/* --- VR hand laser that clicks .clickable, with hover/click colors + zone disable --- */
AFRAME.registerComponent('hand-laser', {
  schema: {
    // visuals
    length:      { type: 'number', default: 6.0 },
    radius:      { type: 'number', default: 0.008 },
    yOffset:     { type: 'number', default: 0.0 },   // optional hand offset
    opacity:     { type: 'number', default: 0.55 },
    emissive:    { type: 'number', default: 1.2 },
    texture:     { type: 'selector', default: '#line' },

    // colors
    colorIdle:   { type: 'color', default: '#0b0b0b' },
    colorHover:  { type: 'color', default: '#ff7a18' },
    colorClick:  { type: 'color', default: '#0841f0' },

    // behavior
    objects:     { type: 'string', default: '.clickable' },
    disableInZones: { type: 'boolean', default: true }
  },

  init: function () {
    this.sceneEl = this.el.sceneEl;
    this.isVR = false;
    this.zoneActive = false;
    this.hovering = false;
    this.pressing = false;
    this.hitEl = null;

    // Ensure raycaster exists (laser-controls usually adds one, but we enforce settings)
    this.el.setAttribute('raycaster', `objects: ${this.data.objects}; far: ${this.data.length}; interval: 0`);
    this.el.setAttribute('cursor', 'rayOrigin: entity; fuse: false');

    // Try to kill the default laser-controls line (we’ll render our own)
    // (laser-controls may re-add it; we keep it invisible)
    this.el.setAttribute('line', 'opacity: 0; visible: false');

    // Build the cylinder laser mesh as a child entity
    this.laserEl = document.createElement('a-entity');
    this.laserEl.setAttribute('visible', false);
    this.laserEl.setAttribute('position', `0 ${this.data.yOffset} 0`);

    // Cylinder is along Y by default; rotate so it points down -Z
    this.laserEl.setAttribute('geometry', {
      primitive: 'cylinder',
      radius: this.data.radius,
      height: this.data.length,
      segmentsRadial: 18,
      openEnded: true
    });
    this.laserEl.setAttribute('rotation', '90 0 0');               // now height goes along Z
    this.laserEl.setAttribute('position', `0 ${this.data.yOffset} ${-this.data.length/2}`); // push forward

    this.laserEl.setAttribute('material', {
      shader: 'laser-gradient',
      src: this.data.texture,
      color: this.data.colorIdle,
      opacity: this.data.opacity,
      emissive: this.data.emissive
    });

    this.el.appendChild(this.laserEl);

    // Raycaster hover
    this.onIntersect = (e) => {
      const els = (e.detail && e.detail.els) || [];
      this.hitEl = els[0] || null;
      this.hovering = !!this.hitEl;
      this._applyColor();
    };

    this.onIntersectCleared = () => {
      this.hitEl = null;
      this.hovering = false;
      this._applyColor();
    };

    // Controller click (Meta Touch etc.)
    this.onDown = () => {
      this.pressing = true;
      this._applyColor();
      if (this.hitEl) {
        // forward click so your existing fade-on-event works unchanged
        this.hitEl.emit('click');
      }
    };

    this.onUp = () => {
      this.pressing = false;
      this._applyColor();
    };

    this.el.addEventListener('raycaster-intersection', this.onIntersect);
    this.el.addEventListener('raycaster-intersection-cleared', this.onIntersectCleared);
    this.el.addEventListener('triggerdown', this.onDown);
    this.el.addEventListener('triggerup', this.onUp);

    // VR-only visibility
    this.onEnterVR = () => { this.isVR = true;  this._refreshEnabled(); };
    this.onExitVR  = () => { this.isVR = false; this._refreshEnabled(); };

    this.sceneEl.addEventListener('enter-vr', this.onEnterVR);
    this.sceneEl.addEventListener('exit-vr',  this.onExitVR);

    // Disable inside your painting zones (your component emits goethe-zone-changed)
    this.onZoneChanged = (e) => {
      if (!this.data.disableInZones) return;
      const name = e.detail && e.detail.name;   // 'blue', 'orange', ... or null
      this.zoneActive = !!name;                 // any zone => disable lasers
      this._refreshEnabled();
    };
    this.sceneEl.addEventListener('goethe-zone-changed', this.onZoneChanged);

    // Initial state
    this._refreshEnabled();
    this._applyColor();
  },

  remove: function () {
    this.el.removeEventListener('raycaster-intersection', this.onIntersect);
    this.el.removeEventListener('raycaster-intersection-cleared', this.onIntersectCleared);
    this.el.removeEventListener('triggerdown', this.onDown);
    this.el.removeEventListener('triggerup', this.onUp);

    if (this.sceneEl) {
      this.sceneEl.removeEventListener('enter-vr', this.onEnterVR);
      this.sceneEl.removeEventListener('exit-vr',  this.onExitVR);
      this.sceneEl.removeEventListener('goethe-zone-changed', this.onZoneChanged);
    }
  },

  _refreshEnabled: function () {
    const enabled = this.isVR && !this.zoneActive;

    this.laserEl.setAttribute('visible', enabled);

    // hard-disable raycaster/cursor when off (prevents accidental interactions)
    this.el.setAttribute('raycaster', 'enabled', enabled);
    this.el.setAttribute('cursor', 'enabled', enabled);

    // keep default line invisible
    this.el.setAttribute('line', 'opacity: 0; visible: false');

    if (!enabled) {
      this.hitEl = null;
      this.hovering = false;
      this.pressing = false;
      this._applyColor();
    }
  },

  _applyColor: function () {
    const c = this.pressing
      ? this.data.colorClick
      : (this.hovering ? this.data.colorHover : this.data.colorIdle);

    if (this.laserEl) {
      this.laserEl.setAttribute('material', 'color', c);
    }
  }
});
</script>

<script>
AFRAME.registerComponent('bgm-manager', {
  schema: {
    src: { type: 'string' },
    volume: { type: 'number', default: 0.75 },
    fadeInMs: { type: 'number', default: 900 },
    fadeOutMs: { type: 'number', default: 600 },
    pauseWhenHidden: { type: 'boolean', default: true }
  },

  init() {
    this.audio = null;

    this.started = false;        // has user clicked Enter at least once?
    this.enabled = true;         // user toggle on/off
    this._fadeRAF = null;

    // Track whether we should auto-resume after tab switch
    this._wasPlayingBeforeHide = false;

    // Start only when the INTRO Enter button is clicked
    this._onEnterClickCapture = (e) => {
      if (this.started) return;

      const btn = e.target.closest?.('.intro-overlay-buttons button');
      if (!btn) return;

      this.started = true;
      if (this.enabled) this._ensureAudioAndPlay(true);
    };
    document.addEventListener('click', this._onEnterClickCapture, true);

    // Pause/resume when tab visibility changes
    this._onVis = () => {
      if (!this.data.pauseWhenHidden) return;
      if (!this.started || !this.audio) return;

      if (document.hidden) {
        this._wasPlayingBeforeHide = this.isPlaying();
        if (this._wasPlayingBeforeHide) this.pause(true);
      } else {
        if (this.enabled && this._wasPlayingBeforeHide) this.play(true);
        this._wasPlayingBeforeHide = false;
      }
    };
    document.addEventListener('visibilitychange', this._onVis);

    // Extra lifecycle events (more reliable on mobile/VR)
this._onPageHide = () => {
  if (!this.data.pauseWhenHidden) return;
  if (!this.started || !this.audio) return;
  this._wasPlayingBeforeHide = this.isPlaying();
  if (this._wasPlayingBeforeHide) this.pause(true);
};

this._onPageShow = () => {
  if (!this.data.pauseWhenHidden) return;
  if (!this.started || !this.audio) return;
  if (this.enabled && this._wasPlayingBeforeHide) this.play(true);
  this._wasPlayingBeforeHide = false;
};

// Some browsers fire these instead of visibilitychange/blur
window.addEventListener('pagehide', this._onPageHide);
window.addEventListener('pageshow', this._onPageShow);

// Optional: modern “frozen tab” events (Chrome)
this._onFreeze = () => this._onPageHide();
this._onResume = () => this._onPageShow();
document.addEventListener('freeze', this._onFreeze);
document.addEventListener('resume', this._onResume);


    // Also handle window blur/focus (some browsers fire these more reliably)
    this._onBlur = () => {
      if (!this.data.pauseWhenHidden) return;
      if (!this.started || !this.audio) return;
      this._wasPlayingBeforeHide = this.isPlaying();
      if (this._wasPlayingBeforeHide) this.pause(true);
    };
    this._onFocus = () => {
      if (!this.data.pauseWhenHidden) return;
      if (!this.started || !this.audio) return;
      if (this.enabled && this._wasPlayingBeforeHide) this.play(true);
      this._wasPlayingBeforeHide = false;
    };
    window.addEventListener('blur', this._onBlur);
    window.addEventListener('focus', this._onFocus);

    // Public API for your UI button
  window.__bgm = {
  toggle: () => this.toggle(),
  play: () => this.play(true),
  pause: () => this.pause(true),
  isOn: () => this.enabled,   // <- key fix
  isPlaying: () => this.isPlaying()
};

  },

  remove() {
    document.removeEventListener('click', this._onEnterClickCapture, true);
    document.removeEventListener('visibilitychange', this._onVis);
    window.removeEventListener('blur', this._onBlur);
    window.removeEventListener('focus', this._onFocus);
    window.removeEventListener('pagehide', this._onPageHide);
window.removeEventListener('pageshow', this._onPageShow);
document.removeEventListener('freeze', this._onFreeze);
document.removeEventListener('resume', this._onResume);

    if (this._fadeRAF) cancelAnimationFrame(this._fadeRAF);
  },

  _ensureAudio() {
    if (this.audio) return;

    this.audio = new Audio(this.data.src);
    this.audio.loop = true;
    this.audio.preload = 'auto';
    this.audio.volume = 0;
  },

  isPlaying() {
    return !!(this.audio && !this.audio.paused);
  },

  async _ensureAudioAndPlay(withFade) {
    this._ensureAudio();

    // try to play
    try {
      await this.audio.play();
    } catch (err) {
      console.warn('[bgm] play blocked/failed:', err);
      return;
    }

    if (withFade) this._fadeTo(this.data.volume, this.data.fadeInMs);
    else this.audio.volume = this.data.volume;

    this.el.sceneEl.emit('bgm-toggled', { enabled: true });
  },

  play(withFade) {
    if (!this.started) return;         // must click Enter first
    if (!this.enabled) return;

    // If audio exists but is paused, resume it
    if (!this.audio || this.audio.paused) {
      this._ensureAudioAndPlay(withFade);
      return;
    }

    // already playing, just ensure volume
    if (withFade) this._fadeTo(this.data.volume, this.data.fadeInMs);
    else this.audio.volume = this.data.volume;

    this.el.sceneEl.emit('bgm-toggled', { enabled: true });
  },

  pause(withFade) {
    if (!this.audio || this.audio.paused) return;

    if (withFade) {
      this._fadeTo(0, this.data.fadeOutMs, () => this.audio.pause());
    } else {
      this.audio.volume = 0;
      this.audio.pause();
    }

    this.el.sceneEl.emit('bgm-toggled', { enabled: false });
  },

  toggle() {
    // If user never clicked Enter, ignore toggle (or you can store intent)
    if (!this.started) {
      this.enabled = !this.enabled;
      this.el.sceneEl.emit('bgm-toggled', { enabled: this.enabled });
      return;
    }

    this.enabled = !this.enabled;

    if (this.enabled) this.play(true);
    else this.pause(true);

    this.el.sceneEl.emit('bgm-toggled', { enabled: this.enabled });
  },

  _fadeTo(target, ms, done) {
    if (!this.audio) return;
    if (this._fadeRAF) cancelAnimationFrame(this._fadeRAF);

    const a = this.audio;
    const from = a.volume;
    const start = performance.now();
    const dur = Math.max(1, ms);

    const step = (now) => {
      const t = Math.min((now - start) / dur, 1);
      const s = t * t * (3 - 2 * t);
      a.volume = from + (target - from) * s;

      if (t < 1) this._fadeRAF = requestAnimationFrame(step);
      else {
        this._fadeRAF = null;
        done && done();
      }
    };

    this._fadeRAF = requestAnimationFrame(step);
  }
});
</script>


  </head>

  <body>
    <div id="ui-topright">
  <button id="btn-music" class="ui-circle" aria-label="Toggle music" title="Music">
    <span id="icon-music"></span>
  </button>
</div>

<style>
#ui-topright{
  position:fixed; top:16px; right:16px; z-index:9999;
}
.ui-circle{
  width:44px; height:44px; border-radius:999px;
  border:1px solid rgba(0,0,0,.15);
  background: rgba(255,255,255,.8);
  backdrop-filter: blur(6px);
  display:grid; place-items:center;
  cursor:pointer;
}
.ui-circle svg{ width:22px; height:22px; display:block; }
</style>

<script>
const ICON_PLAY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M11.596 8.697 6.214 11.96A.5.5 0 0 1 5.5 11.53V4.47a.5.5 0 0 1 .714-.43l5.382 3.263a.5.5 0 0 1 0 .894z"/></svg>`;
const ICON_PAUSE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 3.5A.5.5 0 0 1 6 4v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm5 0A.5.5 0 0 1 11 4v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>`;

function refreshMusicIcon(){
  const on = window.__bgm?.isOn?.() ?? false;
  document.getElementById('icon-music').innerHTML = on ? ICON_PAUSE : ICON_PLAY;
}
document.getElementById('btn-music').addEventListener('click', ()=>{
  window.__bgm?.toggle?.();
  refreshMusicIcon();
});
function bindBgmIconToScene(){
  const scene = document.querySelector('a-scene');
  if (!scene) return false;
  scene.addEventListener('bgm-toggled', refreshMusicIcon);
  refreshMusicIcon();
  return true;
}

window.addEventListener('DOMContentLoaded', () => {
  // Try now, and if scene isn't there yet, retry a few times.
  if (bindBgmIconToScene()) return;
  let tries = 0;
  const t = setInterval(() => {
    tries++;
    if (bindBgmIconToScene() || tries > 50) clearInterval(t);
  }, 50);
});

</script>

    <a-scene 
    light="defaultLightsEnabled: false" 
    background="color: #ffffff" 
    renderer="colorManagement: true; physicallyCorrectLights: true" 
    goethe-zones="rig: #rig"  
    bgm-manager="src: assets/goethe-colors/Liszt_Liebstraum_No3_CC0.mp3;
               volume: 0.75;
               fadeInMs: 900;
               fadeOutMs: 600;
               pauseWhenHidden: true"
    intro-overlay="
   backgroundColor: #ffffff;
    textColor: #000000;
    fontFamily: system-ui;
    fontSize: 1.1rem;

    lang1Code: en;
    lang2Code: fr;
    buttonLabel1: Enter;
    buttonLabel2: Entrer;
    loadingText1: Loading assets…;
    loadingText2: Chargement des éléments…;

    charSpeed: 55;         
    lineGap: 300;         
    imageFadeDuration: 2000;

    text1:
a poet, scientist and philosopher came to a long work on colours, <br>
he studied light, pigments, paintings, psychology... <br>
<br>
And he made his 'Color Theory', as a wide set of reflections and ideas.<br>
There he drafted a purely 'intuitive' diagram <br> 
<br> 
➔ on a possible meaning of colours<br>


;
text2:un poète, scientifique et philosophe a longuement réfléchi sur les couleurs, <br>
il a étudié la lumière, les pigments, la peinture, la psychologie… <br>
<br>
Et il a écrit sa « Théorie des couleurs », un ensemble vaste d’idées et de réflexions. <br>
Il y a dessiné un diagramme particulier, une intuition 
➔ la signification possible des couleurs.<br>;

  

    lang1Code: en;
    lang2Code: fr;
    buttonLabel1: Enter;
    buttonLabel2: Entrer;
    loadingText1: Chargement des éléments…;
    loadingText2: Loading assets…;
  ">

  <a-assets>

    <img id="line" src="assets/goethe-colors/Line.png">

   <a-asset-item id="env" src="assets/goethe-colors/env-goethe.glb"></a-asset-item>
   <a-asset-item id="navmesh" src="assets/goethe-colors/navmesh-env.glb"></a-asset-item>
   <a-asset-item id="table" src="assets/goethe-colors/table.glb"></a-asset-item>
   <img id="diagram" src="assets/goethe-colors/upscale-diagram_png512.png">
   <a-asset-item id="goethe" src="assets/goethe-colors/goethe.glb"></a-asset-item>
   <a-asset-item id="book" src="assets/goethe-colors/Theory-Book.glb"></a-asset-item>
    
     <a-asset-item id="navmesh-blue" src="assets/goethe-colors/navmesh-blue.glb"></a-asset-item>
     <a-asset-item id="navmesh-green" src="assets/goethe-colors/navmesh-green.glb"></a-asset-item>
     <a-asset-item id="navmesh-indigo" src="assets/goethe-colors/navmesh-indigo.glb"></a-asset-item>
     <a-asset-item id="navmesh-orange" src="assets/goethe-colors/navmesh-orange.glb"></a-asset-item>
     <a-asset-item id="navmesh-red" src="assets/goethe-colors/navmesh-red.glb"></a-asset-item>
     <a-asset-item id="navmesh-yellow" src="assets/goethe-colors/navmesh-yellow.glb"></a-asset-item>

     <a-asset-item id="interactable-blue" src="assets/goethe-colors/interactable/interactable-blue.glb"></a-asset-item>
     <a-asset-item id="interactable-green" src="assets/goethe-colors/interactable/interactable-green.glb"></a-asset-item>
     <a-asset-item id="interactable-indigo" src="assets/goethe-colors/interactable/interactable-indigo.glb"></a-asset-item>
     <a-asset-item id="interactable-orange" src="assets/goethe-colors/interactable/interactable-orange.glb"></a-asset-item>
     <a-asset-item id="interactable-red" src="assets/goethe-colors/interactable/interactable-red.glb"></a-asset-item>
     <a-asset-item id="interactable-yellow" src="assets/goethe-colors/interactable/interactable-yellow.glb"></a-asset-item>

    <a-asset-item id="element-blue" src="assets/goethe-colors/elements/blue-element.glb"></a-asset-item>
    <a-asset-item id="element-green" src="assets/goethe-colors/elements/green-element.glb"></a-asset-item>
    <a-asset-item id="element-indigo" src="assets/goethe-colors/elements/indigo-element.glb"></a-asset-item>
    <a-asset-item id="element-orange" src="assets/goethe-colors/elements/orange-element.glb"></a-asset-item>
    <a-asset-item id="element-red" src="assets/goethe-colors/elements/red-element.glb"></a-asset-item>
    <a-asset-item id="element-yellow" src="assets/goethe-colors/elements/yellow-element.glb"></a-asset-item>

    <a-asset-item id="text1" src="assets/goethe-colors/texts-maker/text-JWGoether.glb"></a-asset-item>
    <a-asset-item id="text2" src="assets/goethe-colors/texts-maker/text-diagram.glb"></a-asset-item>
    <a-asset-item id="text3" src="assets/goethe-colors/texts-maker/text-theory.glb"></a-asset-item>

    <a-asset-item id="edel" src="assets/goethe-colors/words compressed/Edel.glb"></a-asset-item>
    <a-asset-item id="gemein" src="assets/goethe-colors/words compressed/Gemein.glb"></a-asset-item>
    <a-asset-item id="gut" src="assets/goethe-colors/words compressed/Gut.glb"></a-asset-item>
    <a-asset-item id="nuztlich" src="assets/goethe-colors/words compressed/Nuztlich.glb"></a-asset-item>
    <a-asset-item id="phantasie" src="assets/goethe-colors/words compressed/phantasie.glb"></a-asset-item>
    <a-asset-item id="schon" src="assets/goethe-colors/words compressed/Schon.glb"></a-asset-item>
    <a-asset-item id="verstand" src="assets/goethe-colors/words compressed/Verstand.glb"></a-asset-item>
    <a-asset-item id="sinnlichkeit" src="assets/goethe-colors/words compressed/sinnlichkeit.glb"></a-asset-item>
    <a-asset-item id="unnothig" src="assets/goethe-colors/words compressed/unnothig.glb"></a-asset-item>
    <a-asset-item id="vernunft" src="assets/goethe-colors/words compressed/Vernunft.glb"></a-asset-item>

    <audio id="bgm" src="assets/goethe-colors/Liszt_Liebstraum_No3_CC0.mp3" preload="auto" loop crossorigin="anonymous"></audio>

  </a-assets>

          <!-- PC & VR Rig -->
<a-entity id="rig" 
spatial-marker
movement-controls="constrainToNavMesh: true ; speed : 0.5; controls: keyboard; enabled:true"  
position="-0.8 0 3.6" rotation="0 -20 0"
simple-navmesh-constraint="navmesh:.navmesh;fall:0;height:0;exclude:.navmesh-hole; "
cursor="rayOrigin: mouse"
raycaster="objects: .clickable">

      <a-box camera="far: 700; fov: 55; near: 0.1; active: true" position="0 1.7 0" visible="false" ></a-box>
      <a-entity id="left-hand"
          laser-controls="hand: left"
          hand-laser="texture: #line;
                      colorIdle: #0b0b0b;
                      colorHover: #ff7a18;
                      colorClick: #0841f0;
                      opacity: 0.55;
                      emissive: 1.2;
                      length: 6;
                      radius: 0.008;">
</a-entity>

<a-entity id="right-hand"
          laser-controls="hand: right"
          hand-laser="texture: #line;
                      colorIdle: #0b0b0b;
                      colorHover: #ff7a18;
                      colorClick: #0841f0;
                      opacity: 0.55;
                      emissive: 1.2;
                      length: 6;
                      radius: 0.008;">
</a-entity>

</a-entity>

 <!-- Sky -->
<a-sky radius="200" theta-length="110" class="environment" material="shader: skyshader; blending: none; anisotropy: 1.04; turbidity: 20; mieCoefficient: 0.1; mieDirectionalG: 0.72; sunPosition: -0.10389385923870163 0.9444896294427422 0.31168157771610494"></a-sky>
  
<!-- Lights -->

<a-entity light="intensity: 1; type: ambient"></a-entity>
<a-entity light="intensity: 1.884; castShadow: true; shadowBias: -0.0002; shadowCameraFov: 0; shadowCameraNear: -2.47; shadowCameraTop: 8.11; shadowCameraRight: 7.68; shadowCameraBottom: -12.3; shadowCameraLeft: -11.9" position="-0.49743 2.96771 1.19041" data-aframe-default-light="" aframe-injected=""></a-entity>
<a-entity light="intensity: 1.5; type: point" position="0 1.88667 0"></a-entity>

<!-- Scene Environement -->
<a-entity gltf-model="#env" rotation="0 -90 0" position="0 0 0" shadow=""></a-entity>
<a-entity gltf-model="#navmesh" rotation="0 -90 0" position="0 0 0" visible="false" class="navmesh"></a-entity>
<a-entity geometry="primitive: ring; radiusInner: 0.6" rotation="90 -9.55 0" position="0 3.5593 0" scale="6.1595 6.1595 6.1595" shadow="" id="extra-light-hidder"></a-entity>

<!-- Goethe's bust + diagram + table -->  
<a-entity id="goethe-bust" gltf-model="assets/goethe-colors/goethe.glb" rotation="0 -90 0" position="-0.00814 0.12423 0.01031" shadow="" class="clickable" gradient-color="color1: #0841f0; color3: #ff0000; color5: #37005c; color6: #ff4000; colorCount: 4; marbleMix: 0.16; roughness: 0.7; metalness: 1; speed: 0.7; originalMix: 0.94" fade-on-event="targets: #goethe-text; duration: 3; hold: 5; group: goetheTexts">
</a-entity>

<!-- Diagram plane → diagram text -->
<a-entity id="diagram-element"
          material="transparent: true; src: #diagram"
          geometry="primitive: plane"
          rotation="-90.00021045914971 62.589336582296 0"
          position="-0.03296 0.81397 0"
          shimmer-material="shimmerIntensity: 1.5"
          class="clickable"
          scale="1.12054 1.12054 1.12054"
          fade-on-event="targets: #diagram-text;
                         duration: 3;
                         hold: 5;
                         from: 0;
                         to: 1;
                         group: goetheTexts">
</a-entity>

<!-- Goethe book → theory text -->
<a-entity id="goethe-book"
          gltf-model="assets/goethe-colors/Theory-Book.glb"
          rotation="0 -90 0"
          position="-0.00824 0.10229 0"
          scale="1 0.87903 1"
          shadow=""
          class="clickable"
          gradient-color="color1: #bfbfbf; color2: #707070; color3: #787878; color4: #b5b5b5; color5: #ebebeb; color6: #a9b181; colorCount: 3; roughness: 0; metalness: 1; speed: 0.1; originalMix: 0"
          fade-on-event="targets: #theory-text;
                         duration: 3;
                         hold: 5;
                         from: 0;
                         to: 1;
                         group: goetheTexts">
</a-entity>



<a-entity gltf-model="#table" rotation="0 -90 0" position="0 0 0" visible="true"></a-entity>



     <!-- navmeshs -->

<!-- ORANGE -->
<a-entity id="navmesh-orange"
          gltf-model="#navmesh-orange"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-orange-area; zone: orange; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- BLUE -->
<a-entity id="navmesh-blue"
          gltf-model="#navmesh-blue"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-blue-area; zone: blue; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- RED -->
<a-entity id="navmesh-red"
          gltf-model="#navmesh-red"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-red-area; zone: red; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- YELLOW -->
<a-entity id="navmesh-yellow"
          gltf-model="#navmesh-yellow"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-yellow-area; zone: yellow; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- GREEN -->
<a-entity id="navmesh-green"
          gltf-model="#navmesh-green"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-green-area; zone: green; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>

<!-- VIOLET / INDIGO -->
<a-entity id="navmesh-indigo"
          gltf-model="#navmesh-indigo"
          rotation="0 -90 0"
          position="0 0 0"
          class="drawingArea navmesh"
          visible="false"
          area-fade-gradient="target: #element-violet-area; zone: indigo; maxOpacity: 1; minOpacity: 0.04; speed: 1">
</a-entity>


  <!-- interactable -->
<a-entity id="btn-blue" gltf-model="#interactable-blue" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>
<a-entity id="btn-green" gltf-model="#interactable-green" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>
<a-entity id="btn-indigo" gltf-model="#interactable-indigo" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>
<a-entity id="btn-orange" gltf-model="#interactable-orange" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>
<a-entity id="btn-red" gltf-model="#interactable-red" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>
<a-entity id="btn-yellow" gltf-model="#interactable-yellow" rotation="0 -90 0" position="0 0 0" shadow="" class="clickable" visible="false"></a-entity>


<!-- drawing space elements -->
<!-- Orange Area -->
<a-entity id="element-orange-area"
          gltf-model="#element-orange"
          rotation="0 -90 0"
          position="0 0 0"
          gradient-color="roughness: 0; color1: #ffffff; color2: #fff1e5; marbleMix: 0.1; opacity: 0; metalness: 1">
</a-entity>

<!-- Blue Area -->
<a-entity id="element-blue-area"
          gltf-model="#element-blue"
          rotation="0 -90 0"
          position="0 0 0"
          gradient-color="color1: #ffffff; color2: #b6c1cd; roughness: 0; opacity: 0">
</a-entity>

<!-- Red Area -->
<a-entity id="element-red-area" gltf-model="assets/goethe-colors/elements/red-element.glb" rotation="0 -90 0" position="0 0.16267 0" gradient-color="color1: #ffffff; color2: #fff5f5; opacity: 0.1">
</a-entity>

<!-- Yellow Area -->
<a-entity id="element-yellow-area"
          gltf-model="#element-yellow"
          rotation="0 -90 0"
          position="0 0 0"
          gradient-color="color1: #ffffff; color2: #eae6d2; opacity: 0; metalness: 1; roughness: 0; marbleMix: 0.1">
</a-entity>

<!-- Green Area -->
<a-entity id="element-green-area"
          gltf-model="#element-green"
          rotation="0 -90 0"
          position="0 0 0"
          gradient-color="color1: #ffffff; color2: #f0fff0; opacity: 0">
</a-entity>

<!-- Violet Area -->
<a-entity id="element-violet-area"
          gltf-model="#element-indigo"
          rotation="0 -90 0"
          position="0 0 0"
          gradient-color="color1: #ffffff; color2: #8b8494; roughness: 0; marbleMix: 0.1; opacity: 0">
</a-entity>


<!-- Marker-Texts -->
<a-entity id="goethe-text" gltf-model="#text1" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>
<a-entity id="diagram-text" gltf-model="#text2" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>
<a-entity id="theory-text" gltf-model="#text3" position="0.02691 1.816 -1.09926" scale="1.5 1.5 1.5" opacity="0" flat-override="color: #000000"></a-entity>

<a-entity id="edel" gltf-model="#edel" position="-0.37194 2.28755 -6.13326" flat-override="opacity: 0.52" scale="0.75 0.75 0.75"></a-entity>
<a-entity id="gut" gltf-model="#gut" position="5.49982 2.42192 -3.10054" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 -71.5990979107282 0"></a-entity>
<a-entity id="nuztlich" gltf-model="#nuztlich" position="4.97181 2.28755 2.96997" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 -126.8201972476418 0"></a-entity>
<a-entity id="gemein" gltf-model="#gemein" position="-0.10445 2.28755 6.31301" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 180 0"></a-entity>
<a-entity id="unnothig" gltf-model="#unnothig" position="-5.21878 2.28755 3.2757" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 126.22317522511548 0"></a-entity>
<a-entity id="schon" gltf-model="#schon" position="-5.45174 2.28755 -3.07225" flat-override="opacity: 0.52" scale="0.75 0.75 0.75" rotation="0 60.677376419944444 0"></a-entity>
<a-entity id="verstand" gltf-model="#verstand" position="3.23791 -0.03986 -0.62757" flat-override="opacity: 0.2" rotation="-53.44607608759832 -70.61074571412753 0"></a-entity>
<a-entity id="sinnlichkeit" gltf-model="#sinnlichkeit" position="1.12832 0.17646 2.8613" flat-override="opacity: 0.2" rotation="-52.5980985508047 -158.30422809008053 4.646687718510977"></a-entity>
<a-entity id="phantasie" gltf-model="#phantasie" position="-3.18411 0.25267 0.40501" flat-override="opacity: 0.2" rotation="-70.0079941136499 94.2475465944545 11.106213900815877"></a-entity>
<a-entity id="vernunft" gltf-model="#vernunft" position="-1.32109 0.22329 -2.73259" flat-override="opacity: 0.2" rotation="-65.7698253030672 21.4790418238643 8.341692539309655"></a-entity>

</a-scene>



  </body>
</html>
