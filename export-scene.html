<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>spatial-marker - export-scene</title>
    <meta name="description" content="A demo of the Spatial-Marker component">
    
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.173.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.173.0/examples/jsm/"
  }
}
</script>

    <script src="spatial-marker.js"></script>

  </head>
  

  <body>

    <a-scene background="color: #ECECEC">

          <!-- PC & VR Rig -->
    <a-entity  id="rig" spatial-marker >
      <a-box id="camera" camera="fov:75; near: 0.1; far: 700"  position="0 1.7 0" visible="false" ></a-box>
      <a-entity id="left-hand"  meta-touch-controls="hand: left"></a-entity>
      <a-entity id="right-hand" meta-touch-controls="hand: right"></a-entity>
    </a-entity>  

      <a-plane position="0 0 -4" rotation="-90 0 0" width="6" height="6" color="#7BC8A4; opacity: 0.0; transparent: true" class="drawingArea"></a-plane>



    </a-scene>

<script type="module">
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

  // ---------- helpers ----------
  function saveBlob(blob, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1500);
  }
  function timestampedName(prefix) {
    const t = new Date(), pad = n => (n<10?'0':'')+n;
    return `${prefix}_${t.getFullYear()}${pad(t.getMonth()+1)}${pad(t.getDate())}_${pad(t.getHours())}${pad(t.getMinutes())}${pad(t.getSeconds())}.glb`;
  }
  function syncWorld(root) { try { root.updateMatrixWorld(true); } catch(_){} }

  // ---------- scene sanitization ----------
  function hidePotentiallyTexturedNodes(root) {
    const toHide = new Set();
    const sels = [
      '#left-hand', '#right-hand',
      '.drawingArea',
      '[src]',              // <a-image>, <a-plane src=...>, etc.
      '[material*="src:"]'  // material with src:
    ];
    sels.forEach(sel => {
      document.querySelectorAll(sel).forEach(el => {
        if (el?.object3D && el.object3D.visible) {
          toHide.add(el.object3D);
        }
      });
    });

    // Also hide any mesh that has a texture map (defensive).
    root.traverse(o => {
      if (o.isMesh) {
        const mats = Array.isArray(o.material) ? o.material : [o.material];
        if (mats.some(m => m && (m.map || m.emissiveMap || m.roughnessMap || m.metalnessMap))) {
          toHide.add(o);
        }
      }
    });

    const hidden = [];
    toHide.forEach(o => { hidden.push({o, v:o.visible}); o.visible = false; });
    return () => hidden.forEach(h => h.o.visible = h.v);
  }

  function sanitizeGeometry(root) {
    const tmp = new Float32Array(3);
    let fixed = 0, dropped = 0;

    root.traverse(o => {
      if (!o.isMesh || !o.geometry || !o.geometry.isBufferGeometry) return;
      const g = o.geometry;

      // Ensure drawRange is valid
      const pos = g.getAttribute('position');
      if (!pos || pos.count < 3) {          // nothing to render
        o.visible = false; dropped++; return;
      }
      g.setDrawRange(0, pos.count);

      // Remove NaN/Inf in positions/normals/uvs
      ['position','normal','uv'].forEach(name => {
        const attr = g.getAttribute(name);
        if (!attr) return;
        const arr = attr.array;
        let dirty = false;
        for (let i=0; i<arr.length; i++) {
          const v = arr[i];
          if (!Number.isFinite(v)) { arr[i] = 0; dirty = true; }
        }
        if (dirty) { attr.needsUpdate = true; fixed++; }
      });

      // If no normals or likely broken, recompute
      if (!g.getAttribute('normal') || !g.getAttribute('normal').count) {
        try { g.computeVertexNormals(); fixed++; } catch(_){}
      }

      // Force indexed geometry for Blender
      if (!g.index) {
        try {
          const indexed = g.toNonIndexed ? null : null; // ensure method exists
          const tmpGeom = g.toNonIndexed ? g.toNonIndexed() : null; // older pattern
        } catch(_){}
        try { g.setIndex([...Array(pos.count).keys()]); fixed++; } catch(_){}
      }
    });
    // console.log('[sanitize]', {fixed, dropped});
  }

  // ---------- exporter presets ----------
  const REGULAR_OPTS = {
    binary: true,
    onlyVisible: true,
    embedImages: true
  };

  const BLENDER_SAFE_OPTS = {
    binary: true,
    onlyVisible: true,
    embedImages: true,           // we hid textured nodes, so this is safe now
    includeCustomExtensions: false,
    forceIndices: true,
    truncateDrawRange: true,
    trs: false
  };

  function exportGLB(root, prefix, opts) {
    const exporter = new GLTFExporter();
    syncWorld(root);

    // Temporarily hide problematic bits & sanitize geometry
    const restore = hidePotentiallyTexturedNodes(root);
    sanitizeGeometry(root);

    exporter.parse(
      root,
      (result) => {
        restore();
        const name = timestampedName(prefix);
        saveBlob(new Blob([result], { type: 'model/gltf-binary' }), name);
      },
      (err) => {
        restore();
        console.warn('[export] failed:', err);
      },
      opts
    );
  }

  // Friendly wrappers
  function exportSceneGLB(root)                  { exportGLB(root, 'spatial-marker', REGULAR_OPTS); }
  function exportSceneGLB_BlenderSafe(root)      { exportGLB(root, 'spatial-marker_blender', BLENDER_SAFE_OPTS); }

  // ---------- desktop shortcuts ----------
  window.addEventListener('keydown', (e) => {
    const scene = document.querySelector('a-scene')?.object3D;
    if (!scene) return;
    const k = (e.key || '').toLowerCase();
    if (k === 'e') exportSceneGLB(scene);             // regular (fast)
    if (k === 'b') exportSceneGLB_BlenderSafe(scene); // Blender-safe (recommended)
  });

  // ---------- VR dual-grip hold ----------
  const HOLD_MS = 600;
  const left  = document.getElementById('left-hand');
  const right = document.getElementById('right-hand');
  const state = { left:false, right:false, timer:null, cooldown:false };

  function tryStartTimer() {
    if (state.timer || state.cooldown) return;
    if (state.left && state.right) {
      state.timer = setTimeout(() => {
        state.timer = null;
        if (state.left && state.right) {
          state.cooldown = true;
          setTimeout(() => state.cooldown = false, 1200);
          const scene = document.querySelector('a-scene')?.object3D;
          if (scene) exportSceneGLB_BlenderSafe(scene);
        }
      }, HOLD_MS);
    }
  }
  function onPress(evt)   { const s = (evt.currentTarget===left)?'left':'right'; state[s]=true;  tryStartTimer(); }
  function onRelease(evt) { const s = (evt.currentTarget===left)?'left':'right'; state[s]=false; if(state.timer){clearTimeout(state.timer); state.timer=null;} }

  ['gripdown','squeezestart'].forEach(e => { left?.addEventListener(e, onPress);  right?.addEventListener(e, onPress);  });
  ['gripup','squeezeend'  ].forEach(e => { left?.addEventListener(e, onRelease); right?.addEventListener(e, onRelease); });
</script>




  </body>
</html>
